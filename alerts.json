[
  {
    "number": 26,
    "created_at": "2024-08-07T16:04:42Z",
    "updated_at": "2024-08-07T16:04:44Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/26",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/26",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/sql-injection",
      "severity": "error",
      "description": "Database query built from user-controlled sources",
      "name": "js/sql-injection",
      "tags": [
        "external/cwe/cwe-089",
        "external/cwe/cwe-090",
        "external/cwe/cwe-943",
        "security"
      ],
      "full_description": "Building a database query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
      "help": "# Database query built from user-controlled sources\nIf a database query (such as a SQL or NoSQL query) is built from user-provided data without sufficient sanitization, a malicious user may be able to run malicious database queries.\n\n\n## Recommendation\nMost database connector libraries offer a way of safely embedding untrusted data into a query by means of query parameters or prepared statements.\n\nFor NoSQL queries, make use of an operator like MongoDB's `$eq` to ensure that untrusted data is interpreted as a literal value and not as a query object. Alternatively, check that the untrusted data is a literal value and not a query object before using it in a query.\n\nFor SQL queries, use query parameters or prepared statements to embed untrusted data into the query string, or use a library like `sqlstring` to escape untrusted data.\n\n\n## Example\nIn the following example, assume the function `handler` is an HTTP request handler in a web application, whose parameter `req` contains the request object.\n\nThe handler constructs an SQL query string from user input and executes it as a database query using the `pg` library. The user input may contain quote characters, so this code is vulnerable to a SQL injection attack.\n\n\n```javascript\nconst app = require(\"express\")(),\n      pg = require(\"pg\"),\n      pool = new pg.Pool(config);\n\napp.get(\"search\", function handler(req, res) {\n  // BAD: the category might have SQL special characters in it\n  var query1 =\n    \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\" +\n    req.params.category +\n    \"' ORDER BY PRICE\";\n  pool.query(query1, [], function(err, results) {\n    // process results\n  });\n});\n\n```\nTo fix this vulnerability, we can use query parameters to embed the user input into the query string. In this example, we use the API offered by the `pg` Postgres database connector library, but other libraries offer similar features. This version is immune to injection attacks.\n\n\n```javascript\nconst app = require(\"express\")(),\n      pg = require(\"pg\"),\n      pool = new pg.Pool(config);\n\napp.get(\"search\", function handler(req, res) {\n  // GOOD: use parameters\n  var query2 =\n    \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=$1 ORDER BY PRICE\";\n  pool.query(query2, [req.params.category], function(err, results) {\n    // process results\n  });\n});\n\n```\nAlternatively, we can use a library like `sqlstring` to escape the user input before embedding it into the query string:\n\n\n```javascript\nconst app = require(\"express\")(),\n      pg = require(\"pg\"),\n      SqlString = require('sqlstring'),\n      pool = new pg.Pool(config);\n\napp.get(\"search\", function handler(req, res) {\n  // GOOD: the category is escaped using mysql.escape\n  var query1 =\n    \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\" +\n    SqlString.escape(req.params.category) +\n    \"' ORDER BY PRICE\";\n  pool.query(query1, [], function(err, results) {\n    // process results\n  });\n});\n\n```\n\n## Example\nIn the following example, an express handler attempts to delete a single document from a MongoDB collection. The document to be deleted is identified by its `_id` field, which is constructed from user input. The user input may contain a query object, so this code is vulnerable to a NoSQL injection attack.\n\n\n```javascript\nconst express = require(\"express\");\nconst mongoose = require(\"mongoose\");\nconst Todo = mongoose.model(\n  \"Todo\",\n  new mongoose.Schema({ text: { type: String } }, { timestamps: true })\n);\n\nconst app = express();\napp.use(express.json());\napp.use(express.urlencoded({ extended: false }));\n\napp.delete(\"/api/delete\", async (req, res) => {\n  let id = req.body.id;\n\n  await Todo.deleteOne({ _id: id }); // BAD: id might be an object with special properties\n\n  res.json({ status: \"ok\" });\n});\n\n```\nTo fix this vulnerability, we can use the `$eq` operator to ensure that the user input is interpreted as a literal value and not as a query object:\n\n\n```javascript\napp.delete(\"/api/delete\", async (req, res) => {\n  let id = req.body.id;\n  await Todo.deleteOne({ _id: { $eq: id } }); // GOOD: using $eq operator for the comparison\n\n  res.json({ status: \"ok\" });\n});\n```\nAlternatively check that the user input is a literal value and not a query object before using it:\n\n\n```javascript\napp.delete(\"/api/delete\", async (req, res) => {\n  let id = req.body.id;\n  if (typeof id !== \"string\") {\n    res.status(400).json({ status: \"error\" });\n    return;\n  }\n  await Todo.deleteOne({ _id: id }); // GOOD: id is guaranteed to be a string\n\n  res.json({ status: \"ok\" });\n});\n\n```\n\n## References\n* Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).\n* MongoDB: [$eq operator](https://docs.mongodb.com/manual/reference/operator/query/eq).\n* OWASP: [NoSQL injection](https://owasp.org/www-pdf-archive/GOD16-NOSQL.pdf).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).\n* Common Weakness Enumeration: [CWE-943](https://cwe.mitre.org/data/definitions/943.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:javascript-typescript",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "This query string depends on a user-provided value.\nThis query string depends on a user-provided value."
      },
      "location": {
        "path": "model/products.js",
        "start_line": 40,
        "end_line": 40,
        "start_column": 19,
        "end_column": 20
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/26/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 25,
    "created_at": "2024-08-07T16:04:42Z",
    "updated_at": "2024-08-07T16:04:44Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/25",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/25",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/sql-injection",
      "severity": "error",
      "description": "Database query built from user-controlled sources",
      "name": "js/sql-injection",
      "tags": [
        "external/cwe/cwe-089",
        "external/cwe/cwe-090",
        "external/cwe/cwe-943",
        "security"
      ],
      "full_description": "Building a database query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
      "help": "# Database query built from user-controlled sources\nIf a database query (such as a SQL or NoSQL query) is built from user-provided data without sufficient sanitization, a malicious user may be able to run malicious database queries.\n\n\n## Recommendation\nMost database connector libraries offer a way of safely embedding untrusted data into a query by means of query parameters or prepared statements.\n\nFor NoSQL queries, make use of an operator like MongoDB's `$eq` to ensure that untrusted data is interpreted as a literal value and not as a query object. Alternatively, check that the untrusted data is a literal value and not a query object before using it in a query.\n\nFor SQL queries, use query parameters or prepared statements to embed untrusted data into the query string, or use a library like `sqlstring` to escape untrusted data.\n\n\n## Example\nIn the following example, assume the function `handler` is an HTTP request handler in a web application, whose parameter `req` contains the request object.\n\nThe handler constructs an SQL query string from user input and executes it as a database query using the `pg` library. The user input may contain quote characters, so this code is vulnerable to a SQL injection attack.\n\n\n```javascript\nconst app = require(\"express\")(),\n      pg = require(\"pg\"),\n      pool = new pg.Pool(config);\n\napp.get(\"search\", function handler(req, res) {\n  // BAD: the category might have SQL special characters in it\n  var query1 =\n    \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\" +\n    req.params.category +\n    \"' ORDER BY PRICE\";\n  pool.query(query1, [], function(err, results) {\n    // process results\n  });\n});\n\n```\nTo fix this vulnerability, we can use query parameters to embed the user input into the query string. In this example, we use the API offered by the `pg` Postgres database connector library, but other libraries offer similar features. This version is immune to injection attacks.\n\n\n```javascript\nconst app = require(\"express\")(),\n      pg = require(\"pg\"),\n      pool = new pg.Pool(config);\n\napp.get(\"search\", function handler(req, res) {\n  // GOOD: use parameters\n  var query2 =\n    \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=$1 ORDER BY PRICE\";\n  pool.query(query2, [req.params.category], function(err, results) {\n    // process results\n  });\n});\n\n```\nAlternatively, we can use a library like `sqlstring` to escape the user input before embedding it into the query string:\n\n\n```javascript\nconst app = require(\"express\")(),\n      pg = require(\"pg\"),\n      SqlString = require('sqlstring'),\n      pool = new pg.Pool(config);\n\napp.get(\"search\", function handler(req, res) {\n  // GOOD: the category is escaped using mysql.escape\n  var query1 =\n    \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\" +\n    SqlString.escape(req.params.category) +\n    \"' ORDER BY PRICE\";\n  pool.query(query1, [], function(err, results) {\n    // process results\n  });\n});\n\n```\n\n## Example\nIn the following example, an express handler attempts to delete a single document from a MongoDB collection. The document to be deleted is identified by its `_id` field, which is constructed from user input. The user input may contain a query object, so this code is vulnerable to a NoSQL injection attack.\n\n\n```javascript\nconst express = require(\"express\");\nconst mongoose = require(\"mongoose\");\nconst Todo = mongoose.model(\n  \"Todo\",\n  new mongoose.Schema({ text: { type: String } }, { timestamps: true })\n);\n\nconst app = express();\napp.use(express.json());\napp.use(express.urlencoded({ extended: false }));\n\napp.delete(\"/api/delete\", async (req, res) => {\n  let id = req.body.id;\n\n  await Todo.deleteOne({ _id: id }); // BAD: id might be an object with special properties\n\n  res.json({ status: \"ok\" });\n});\n\n```\nTo fix this vulnerability, we can use the `$eq` operator to ensure that the user input is interpreted as a literal value and not as a query object:\n\n\n```javascript\napp.delete(\"/api/delete\", async (req, res) => {\n  let id = req.body.id;\n  await Todo.deleteOne({ _id: { $eq: id } }); // GOOD: using $eq operator for the comparison\n\n  res.json({ status: \"ok\" });\n});\n```\nAlternatively check that the user input is a literal value and not a query object before using it:\n\n\n```javascript\napp.delete(\"/api/delete\", async (req, res) => {\n  let id = req.body.id;\n  if (typeof id !== \"string\") {\n    res.status(400).json({ status: \"error\" });\n    return;\n  }\n  await Todo.deleteOne({ _id: id }); // GOOD: id is guaranteed to be a string\n\n  res.json({ status: \"ok\" });\n});\n\n```\n\n## References\n* Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).\n* MongoDB: [$eq operator](https://docs.mongodb.com/manual/reference/operator/query/eq).\n* OWASP: [NoSQL injection](https://owasp.org/www-pdf-archive/GOD16-NOSQL.pdf).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).\n* Common Weakness Enumeration: [CWE-943](https://cwe.mitre.org/data/definitions/943.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:javascript-typescript",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "This query string depends on a user-provided value."
      },
      "location": {
        "path": "model/products.js",
        "start_line": 23,
        "end_line": 23,
        "start_column": 20,
        "end_column": 21
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/25/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 24,
    "created_at": "2024-08-07T16:04:42Z",
    "updated_at": "2024-08-07T16:04:44Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/24",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/24",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/sql-injection",
      "severity": "error",
      "description": "Database query built from user-controlled sources",
      "name": "js/sql-injection",
      "tags": [
        "external/cwe/cwe-089",
        "external/cwe/cwe-090",
        "external/cwe/cwe-943",
        "security"
      ],
      "full_description": "Building a database query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
      "help": "# Database query built from user-controlled sources\nIf a database query (such as a SQL or NoSQL query) is built from user-provided data without sufficient sanitization, a malicious user may be able to run malicious database queries.\n\n\n## Recommendation\nMost database connector libraries offer a way of safely embedding untrusted data into a query by means of query parameters or prepared statements.\n\nFor NoSQL queries, make use of an operator like MongoDB's `$eq` to ensure that untrusted data is interpreted as a literal value and not as a query object. Alternatively, check that the untrusted data is a literal value and not a query object before using it in a query.\n\nFor SQL queries, use query parameters or prepared statements to embed untrusted data into the query string, or use a library like `sqlstring` to escape untrusted data.\n\n\n## Example\nIn the following example, assume the function `handler` is an HTTP request handler in a web application, whose parameter `req` contains the request object.\n\nThe handler constructs an SQL query string from user input and executes it as a database query using the `pg` library. The user input may contain quote characters, so this code is vulnerable to a SQL injection attack.\n\n\n```javascript\nconst app = require(\"express\")(),\n      pg = require(\"pg\"),\n      pool = new pg.Pool(config);\n\napp.get(\"search\", function handler(req, res) {\n  // BAD: the category might have SQL special characters in it\n  var query1 =\n    \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\" +\n    req.params.category +\n    \"' ORDER BY PRICE\";\n  pool.query(query1, [], function(err, results) {\n    // process results\n  });\n});\n\n```\nTo fix this vulnerability, we can use query parameters to embed the user input into the query string. In this example, we use the API offered by the `pg` Postgres database connector library, but other libraries offer similar features. This version is immune to injection attacks.\n\n\n```javascript\nconst app = require(\"express\")(),\n      pg = require(\"pg\"),\n      pool = new pg.Pool(config);\n\napp.get(\"search\", function handler(req, res) {\n  // GOOD: use parameters\n  var query2 =\n    \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=$1 ORDER BY PRICE\";\n  pool.query(query2, [req.params.category], function(err, results) {\n    // process results\n  });\n});\n\n```\nAlternatively, we can use a library like `sqlstring` to escape the user input before embedding it into the query string:\n\n\n```javascript\nconst app = require(\"express\")(),\n      pg = require(\"pg\"),\n      SqlString = require('sqlstring'),\n      pool = new pg.Pool(config);\n\napp.get(\"search\", function handler(req, res) {\n  // GOOD: the category is escaped using mysql.escape\n  var query1 =\n    \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\" +\n    SqlString.escape(req.params.category) +\n    \"' ORDER BY PRICE\";\n  pool.query(query1, [], function(err, results) {\n    // process results\n  });\n});\n\n```\n\n## Example\nIn the following example, an express handler attempts to delete a single document from a MongoDB collection. The document to be deleted is identified by its `_id` field, which is constructed from user input. The user input may contain a query object, so this code is vulnerable to a NoSQL injection attack.\n\n\n```javascript\nconst express = require(\"express\");\nconst mongoose = require(\"mongoose\");\nconst Todo = mongoose.model(\n  \"Todo\",\n  new mongoose.Schema({ text: { type: String } }, { timestamps: true })\n);\n\nconst app = express();\napp.use(express.json());\napp.use(express.urlencoded({ extended: false }));\n\napp.delete(\"/api/delete\", async (req, res) => {\n  let id = req.body.id;\n\n  await Todo.deleteOne({ _id: id }); // BAD: id might be an object with special properties\n\n  res.json({ status: \"ok\" });\n});\n\n```\nTo fix this vulnerability, we can use the `$eq` operator to ensure that the user input is interpreted as a literal value and not as a query object:\n\n\n```javascript\napp.delete(\"/api/delete\", async (req, res) => {\n  let id = req.body.id;\n  await Todo.deleteOne({ _id: { $eq: id } }); // GOOD: using $eq operator for the comparison\n\n  res.json({ status: \"ok\" });\n});\n```\nAlternatively check that the user input is a literal value and not a query object before using it:\n\n\n```javascript\napp.delete(\"/api/delete\", async (req, res) => {\n  let id = req.body.id;\n  if (typeof id !== \"string\") {\n    res.status(400).json({ status: \"error\" });\n    return;\n  }\n  await Todo.deleteOne({ _id: id }); // GOOD: id is guaranteed to be a string\n\n  res.json({ status: \"ok\" });\n});\n\n```\n\n## References\n* Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).\n* MongoDB: [$eq operator](https://docs.mongodb.com/manual/reference/operator/query/eq).\n* OWASP: [NoSQL injection](https://owasp.org/www-pdf-archive/GOD16-NOSQL.pdf).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).\n* Common Weakness Enumeration: [CWE-943](https://cwe.mitre.org/data/definitions/943.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:javascript-typescript",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "This query string depends on a user-provided value."
      },
      "location": {
        "path": "model/products.js",
        "start_line": 16,
        "end_line": 16,
        "start_column": 19,
        "end_column": 20
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/24/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 23,
    "created_at": "2024-08-07T16:04:42Z",
    "updated_at": "2024-08-07T16:04:44Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/23",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/23",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/sql-injection",
      "severity": "error",
      "description": "Database query built from user-controlled sources",
      "name": "js/sql-injection",
      "tags": [
        "external/cwe/cwe-089",
        "external/cwe/cwe-090",
        "external/cwe/cwe-943",
        "security"
      ],
      "full_description": "Building a database query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
      "help": "# Database query built from user-controlled sources\nIf a database query (such as a SQL or NoSQL query) is built from user-provided data without sufficient sanitization, a malicious user may be able to run malicious database queries.\n\n\n## Recommendation\nMost database connector libraries offer a way of safely embedding untrusted data into a query by means of query parameters or prepared statements.\n\nFor NoSQL queries, make use of an operator like MongoDB's `$eq` to ensure that untrusted data is interpreted as a literal value and not as a query object. Alternatively, check that the untrusted data is a literal value and not a query object before using it in a query.\n\nFor SQL queries, use query parameters or prepared statements to embed untrusted data into the query string, or use a library like `sqlstring` to escape untrusted data.\n\n\n## Example\nIn the following example, assume the function `handler` is an HTTP request handler in a web application, whose parameter `req` contains the request object.\n\nThe handler constructs an SQL query string from user input and executes it as a database query using the `pg` library. The user input may contain quote characters, so this code is vulnerable to a SQL injection attack.\n\n\n```javascript\nconst app = require(\"express\")(),\n      pg = require(\"pg\"),\n      pool = new pg.Pool(config);\n\napp.get(\"search\", function handler(req, res) {\n  // BAD: the category might have SQL special characters in it\n  var query1 =\n    \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\" +\n    req.params.category +\n    \"' ORDER BY PRICE\";\n  pool.query(query1, [], function(err, results) {\n    // process results\n  });\n});\n\n```\nTo fix this vulnerability, we can use query parameters to embed the user input into the query string. In this example, we use the API offered by the `pg` Postgres database connector library, but other libraries offer similar features. This version is immune to injection attacks.\n\n\n```javascript\nconst app = require(\"express\")(),\n      pg = require(\"pg\"),\n      pool = new pg.Pool(config);\n\napp.get(\"search\", function handler(req, res) {\n  // GOOD: use parameters\n  var query2 =\n    \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=$1 ORDER BY PRICE\";\n  pool.query(query2, [req.params.category], function(err, results) {\n    // process results\n  });\n});\n\n```\nAlternatively, we can use a library like `sqlstring` to escape the user input before embedding it into the query string:\n\n\n```javascript\nconst app = require(\"express\")(),\n      pg = require(\"pg\"),\n      SqlString = require('sqlstring'),\n      pool = new pg.Pool(config);\n\napp.get(\"search\", function handler(req, res) {\n  // GOOD: the category is escaped using mysql.escape\n  var query1 =\n    \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\" +\n    SqlString.escape(req.params.category) +\n    \"' ORDER BY PRICE\";\n  pool.query(query1, [], function(err, results) {\n    // process results\n  });\n});\n\n```\n\n## Example\nIn the following example, an express handler attempts to delete a single document from a MongoDB collection. The document to be deleted is identified by its `_id` field, which is constructed from user input. The user input may contain a query object, so this code is vulnerable to a NoSQL injection attack.\n\n\n```javascript\nconst express = require(\"express\");\nconst mongoose = require(\"mongoose\");\nconst Todo = mongoose.model(\n  \"Todo\",\n  new mongoose.Schema({ text: { type: String } }, { timestamps: true })\n);\n\nconst app = express();\napp.use(express.json());\napp.use(express.urlencoded({ extended: false }));\n\napp.delete(\"/api/delete\", async (req, res) => {\n  let id = req.body.id;\n\n  await Todo.deleteOne({ _id: id }); // BAD: id might be an object with special properties\n\n  res.json({ status: \"ok\" });\n});\n\n```\nTo fix this vulnerability, we can use the `$eq` operator to ensure that the user input is interpreted as a literal value and not as a query object:\n\n\n```javascript\napp.delete(\"/api/delete\", async (req, res) => {\n  let id = req.body.id;\n  await Todo.deleteOne({ _id: { $eq: id } }); // GOOD: using $eq operator for the comparison\n\n  res.json({ status: \"ok\" });\n});\n```\nAlternatively check that the user input is a literal value and not a query object before using it:\n\n\n```javascript\napp.delete(\"/api/delete\", async (req, res) => {\n  let id = req.body.id;\n  if (typeof id !== \"string\") {\n    res.status(400).json({ status: \"error\" });\n    return;\n  }\n  await Todo.deleteOne({ _id: id }); // GOOD: id is guaranteed to be a string\n\n  res.json({ status: \"ok\" });\n});\n\n```\n\n## References\n* Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).\n* MongoDB: [$eq operator](https://docs.mongodb.com/manual/reference/operator/query/eq).\n* OWASP: [NoSQL injection](https://owasp.org/www-pdf-archive/GOD16-NOSQL.pdf).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).\n* Common Weakness Enumeration: [CWE-943](https://cwe.mitre.org/data/definitions/943.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:javascript-typescript",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "This query string depends on a user-provided value.\nThis query string depends on a user-provided value."
      },
      "location": {
        "path": "model/auth.js",
        "start_line": 9,
        "end_line": 9,
        "start_column": 19,
        "end_column": 20
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/23/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 16,
    "created_at": "2024-08-07T16:04:42Z",
    "updated_at": "2024-08-07T16:04:44Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/16",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/16",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/xss",
      "severity": "error",
      "description": "Client-side cross-site scripting",
      "name": "js/xss",
      "tags": [
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "security"
      ],
      "full_description": "Writing user input directly to the DOM allows for a cross-site scripting vulnerability.",
      "help": "# Client-side cross-site scripting\nDirectly writing user input (for example, a URL query parameter) to a webpage without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\nThis kind of vulnerability is also called *DOM-based* cross-site scripting, to distinguish it from other types of cross-site scripting.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the page, or one of the other solutions that are mentioned in the references.\n\n\n## Example\nThe following example shows part of the page URL being written directly to the document, leaving the website vulnerable to cross-site scripting.\n\n\n```javascript\nfunction setLanguageOptions() {\n    var href = document.location.href,\n        deflt = href.substring(href.indexOf(\"default=\")+8);\n    document.write(\"<OPTION value=1>\"+deflt+\"</OPTION>\");\n    document.write(\"<OPTION value=2>English</OPTION>\");\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:javascript-typescript",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "Cross-site scripting vulnerability due to user-provided value."
      },
      "location": {
        "path": "views/search.ejs",
        "start_line": 3,
        "end_line": 3,
        "start_column": 18,
        "end_column": 33
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/16/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 15,
    "created_at": "2024-08-07T16:04:42Z",
    "updated_at": "2024-08-07T16:04:44Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/15",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/15",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/xss",
      "severity": "error",
      "description": "Client-side cross-site scripting",
      "name": "js/xss",
      "tags": [
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "security"
      ],
      "full_description": "Writing user input directly to the DOM allows for a cross-site scripting vulnerability.",
      "help": "# Client-side cross-site scripting\nDirectly writing user input (for example, a URL query parameter) to a webpage without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\nThis kind of vulnerability is also called *DOM-based* cross-site scripting, to distinguish it from other types of cross-site scripting.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the page, or one of the other solutions that are mentioned in the references.\n\n\n## Example\nThe following example shows part of the page URL being written directly to the document, leaving the website vulnerable to cross-site scripting.\n\n\n```javascript\nfunction setLanguageOptions() {\n    var href = document.location.href,\n        deflt = href.substring(href.indexOf(\"default=\")+8);\n    document.write(\"<OPTION value=1>\"+deflt+\"</OPTION>\");\n    document.write(\"<OPTION value=2>English</OPTION>\");\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:javascript-typescript",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "Cross-site scripting vulnerability due to user-provided value."
      },
      "location": {
        "path": "views/login.ejs",
        "start_line": 22,
        "end_line": 22,
        "start_column": 46,
        "end_column": 61
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/15/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 14,
    "created_at": "2024-08-07T16:04:42Z",
    "updated_at": "2024-08-07T16:04:44Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/14",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/14",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/xss",
      "severity": "error",
      "description": "Client-side cross-site scripting",
      "name": "js/xss",
      "tags": [
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "security"
      ],
      "full_description": "Writing user input directly to the DOM allows for a cross-site scripting vulnerability.",
      "help": "# Client-side cross-site scripting\nDirectly writing user input (for example, a URL query parameter) to a webpage without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\nThis kind of vulnerability is also called *DOM-based* cross-site scripting, to distinguish it from other types of cross-site scripting.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the page, or one of the other solutions that are mentioned in the references.\n\n\n## Example\nThe following example shows part of the page URL being written directly to the document, leaving the website vulnerable to cross-site scripting.\n\n\n```javascript\nfunction setLanguageOptions() {\n    var href = document.location.href,\n        deflt = href.substring(href.indexOf(\"default=\")+8);\n    document.write(\"<OPTION value=1>\"+deflt+\"</OPTION>\");\n    document.write(\"<OPTION value=2>English</OPTION>\");\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:javascript-typescript",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "Cross-site scripting vulnerability due to user-provided value."
      },
      "location": {
        "path": "views/login.ejs",
        "start_line": 17,
        "end_line": 17,
        "start_column": 94,
        "end_column": 108
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/14/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 5,
    "created_at": "2024-08-07T16:04:42Z",
    "updated_at": "2024-08-07T16:04:44Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/5",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/5",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/missing-token-validation",
      "severity": "error",
      "description": "Missing CSRF middleware",
      "name": "js/missing-token-validation",
      "tags": [
        "external/cwe/cwe-352",
        "security"
      ],
      "full_description": "Using cookies without CSRF protection may allow malicious websites to submit requests on behalf of the user.",
      "help": "# Missing CSRF middleware\nWebsites that rely on cookie-based authentication may be vulnerable to cross-site request forgery (CSRF). Specifically, a state-changing request should include a secret token so the request can't be forged by an attacker. Otherwise, unwanted requests can be submitted on behalf of a user who visits a malicious website.\n\nThis is typically mitigated by embedding a session-specific secret token in each request. This token is then checked as an additional authentication measure. A malicious website should have no way of guessing the correct token to embed in the request.\n\n\n## Recommendation\nUse a middleware package such as `lusca.csrf` to protect against CSRF attacks.\n\n\n## Example\nIn the example below, the server authenticates users before performing the `changeEmail` POST action:\n\n\n```javascript\nconst app = require(\"express\")(),\n  cookieParser = require(\"cookie-parser\"),\n  bodyParser = require(\"body-parser\"),\n  session = require(\"express-session\");\n\napp.use(cookieParser());\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(session({ secret: process.env['SECRET'], cookie: { maxAge: 60000 } }));\n\n// ...\n\napp.post(\"/changeEmail\", function(req, res) {\n  const userId = req.session.id;\n  const email = req.body[\"email\"];\n  // ... update email associated with userId\n});\n\n```\nThis is not secure. An attacker can submit a POST `changeEmail` request on behalf of a user who visited a malicious website. Since authentication happens without any action from the user, the `changeEmail` action would be executed, despite not being initiated by the user.\n\nThis vulnerability can be mitigated by installing a CSRF protecting middleware handler:\n\n\n```javascript\nconst app = require(\"express\")(),\n  cookieParser = require(\"cookie-parser\"),\n  bodyParser = require(\"body-parser\"),\n  session = require(\"express-session\"),\n  csrf = require('lusca').csrf;\n\napp.use(cookieParser());\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(session({ secret: process.env['SECRET'], cookie: { maxAge: 60000 } }));\napp.use(csrf());\n\n// ...\n\napp.post(\"/changeEmail\", function(req, res) {\n  const userId = req.session.id;\n  const email = req.body[\"email\"];\n  // ... update email associated with userId\n});\n\n```\n\n## References\n* OWASP: [Cross-Site Request Forgery (CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))\n* NPM: [lusca](https://www.npmjs.com/package/lusca)\n* Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:javascript-typescript",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "This cookie middleware is serving a request handler without CSRF protection."
      },
      "location": {
        "path": "app.js",
        "start_line": 41,
        "end_line": 41,
        "start_column": 9,
        "end_column": 23
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/5/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 4,
    "created_at": "2024-08-07T16:04:42Z",
    "updated_at": "2024-08-07T16:04:44Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/4",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/4",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/missing-rate-limiting",
      "severity": "warning",
      "description": "Missing rate limiting",
      "name": "js/missing-rate-limiting",
      "tags": [
        "external/cwe/cwe-307",
        "external/cwe/cwe-400",
        "external/cwe/cwe-770",
        "security"
      ],
      "full_description": "An HTTP request handler that performs expensive operations without restricting the rate at which operations can be carried out is vulnerable to denial-of-service attacks.",
      "help": "# Missing rate limiting\nHTTP request handlers should not perform expensive operations such as accessing the file system, executing an operating system command or interacting with a database without limiting the rate at which requests are accepted. Otherwise, the application becomes vulnerable to denial-of-service attacks where an attacker can cause the application to crash or become unresponsive by issuing a large number of requests at the same time.\n\n\n## Recommendation\nA rate-limiting middleware should be used to prevent such attacks.\n\n\n## Example\nThe following example shows an Express application that serves static files without rate limiting:\n\n\n```javascript\nvar express = require('express');\nvar app = express();\n\napp.get('/:path', function(req, res) {\n  let path = req.params.path;\n  if (isValidPath(path))\n    res.sendFile(path);\n});\n\n```\nTo prevent denial-of-service attacks, the `express-rate-limit` package can be used:\n\n\n```javascript\nvar express = require('express');\nvar app = express();\n\n// set up rate limiter: maximum of five requests per minute\nvar RateLimit = require('express-rate-limit');\nvar limiter = RateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // max 100 requests per windowMs\n});\n\n// apply rate limiter to all requests\napp.use(limiter);\n\napp.get('/:path', function(req, res) {\n  let path = req.params.path;\n  if (isValidPath(path))\n    res.sendFile(path);\n});\n\n```\n\n## References\n* OWASP: [Denial of Service Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html).\n* Wikipedia: [Denial-of-service attack](https://en.wikipedia.org/wiki/Denial-of-service_attack).\n* NPM: [express-rate-limit](https://www.npmjs.com/package/express-rate-limit).\n* Common Weakness Enumeration: [CWE-770](https://cwe.mitre.org/data/definitions/770.html).\n* Common Weakness Enumeration: [CWE-307](https://cwe.mitre.org/data/definitions/307.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:javascript-typescript",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "This route handler performs authorization, but is not rate-limited."
      },
      "location": {
        "path": "routes/login.js",
        "start_line": 19,
        "end_line": 42,
        "start_column": 28,
        "end_column": 2
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/4/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 2,
    "created_at": "2024-08-07T16:04:42Z",
    "updated_at": "2024-08-07T16:04:44Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/2",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/2",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/polynomial-redos",
      "severity": "warning",
      "description": "Polynomial regular expression used on uncontrolled data",
      "name": "js/polynomial-redos",
      "tags": [
        "external/cwe/cwe-1333",
        "external/cwe/cwe-400",
        "external/cwe/cwe-730",
        "security"
      ],
      "full_description": "A regular expression that can require polynomial time to match may be vulnerable to denial-of-service attacks.",
      "help": "# Polynomial regular expression used on uncontrolled data\nSome regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting an expensive input string for the regular expression to match.\n\nThe regular expression engines provided by many popular JavaScript platforms use backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.\n\nTypically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.\n\n\n## Recommendation\nModify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter.\n\n\n## Example\nConsider this use of a regular expression, which removes all leading and trailing whitespace in a string:\n\n```javascript\n\ntext.replace(/^\\s+|\\s+$/g, ''); // BAD\n```\nThe sub-expression `\"\\s+$\"` will match the whitespace characters in `text` from left to right, but it can start matching anywhere within a whitespace sequence. This is problematic for strings that do **not** end with a whitespace character. Such a string will force the regular expression engine to process each whitespace sequence once per whitespace character in the sequence.\n\nThis ultimately means that the time cost of trimming a string is quadratic in the length of the string. So a string like `\"a b\"` will take milliseconds to process, but a similar string with a million spaces instead of just one will take several minutes.\n\nAvoid this problem by rewriting the regular expression to not contain the ambiguity about when to start matching whitespace sequences. For instance, by using a negative look-behind (`/^\\s+|(?<!\\s)\\s+$/g`), or just by using the built-in trim method (`text.trim()`).\n\nNote that the sub-expression `\"^\\s+\"` is **not** problematic as the `^` anchor restricts when that sub-expression can start matching, and as the regular expression engine matches from left to right.\n\n\n## Example\nAs a similar, but slightly subtler problem, consider the regular expression that matches lines with numbers, possibly written using scientific notation:\n\n```javascript\n\n/^0\\.\\d+E?\\d+$/.test(str) // BAD\n```\nThe problem with this regular expression is in the sub-expression `\\d+E?\\d+` because the second `\\d+` can start matching digits anywhere after the first match of the first `\\d+` if there is no `E` in the input string.\n\nThis is problematic for strings that do **not** end with a digit. Such a string will force the regular expression engine to process each digit sequence once per digit in the sequence, again leading to a quadratic time complexity.\n\nTo make the processing faster, the regular expression should be rewritten such that the two `\\d+` sub-expressions do not have overlapping matches: `^0\\.\\d+(E\\d+)?$`.\n\n\n## Example\nSometimes it is unclear how a regular expression can be rewritten to avoid the problem. In such cases, it often suffices to limit the length of the input string. For instance, the following regular expression is used to match numbers, and on some non-number inputs it can have quadratic time complexity:\n\n```javascript\n\n/^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\d+)?$/.test(str) // BAD\n```\nIt is not immediately obvious how to rewrite this regular expression to avoid the problem. However, you can mitigate performance issues by limiting the length to 1000 characters, which will always finish in a reasonable amount of time.\n\n```javascript\n\nif (str.length > 1000) {\n    throw new Error(\"Input too long\");\n}\n\n/^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\d+)?$/.test(str)\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:javascript-typescript",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "This regular expression that depends on a user-provided value may run slow on strings starting with '0' and with many repetitions of '0'.\nThis regular expression that depends on a user-provided value may run slow on strings starting with '0' and with many repetitions of '0'."
      },
      "location": {
        "path": "routes/products.js",
        "start_line": 121,
        "end_line": 121,
        "start_column": 14,
        "end_column": 32
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/2/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 1,
    "created_at": "2024-08-07T16:04:42Z",
    "updated_at": "2024-08-07T16:04:44Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/1",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/1",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/redos",
      "severity": "error",
      "description": "Inefficient regular expression",
      "name": "js/redos",
      "tags": [
        "external/cwe/cwe-1333",
        "external/cwe/cwe-400",
        "external/cwe/cwe-730",
        "security"
      ],
      "full_description": "A regular expression that requires exponential time to match certain inputs can be a performance bottleneck, and may be vulnerable to denial-of-service attacks.",
      "help": "# Inefficient regular expression\nSome regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting an expensive input string for the regular expression to match.\n\nThe regular expression engines provided by many popular JavaScript platforms use backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.\n\nTypically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.\n\n\n## Recommendation\nModify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter.\n\n\n## Example\nConsider this regular expression:\n\n```javascript\n\n/^_(__|.)+_$/\n```\nIts sub-expression `\"(__|.)+?\"` can match the string `\"__\"` either by the first alternative `\"__\"` to the left of the `\"|\"` operator, or by two repetitions of the second alternative `\".\"` to the right. Thus, a string consisting of an odd number of underscores followed by some other character will cause the regular expression engine to run for an exponential amount of time before rejecting the input.\n\nThis problem can be avoided by rewriting the regular expression to remove the ambiguity between the two branches of the alternative inside the repetition:\n\n```javascript\n\n/^_(__|[^_])+_$/\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:javascript-typescript",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "This part of the regular expression may cause exponential backtracking on strings starting with '0' and containing many repetitions of '0'."
      },
      "location": {
        "path": "routes/products.js",
        "start_line": 120,
        "end_line": 120,
        "start_column": 48,
        "end_column": 60
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/1/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 8207,
    "created_at": "2025-03-19T18:29:50Z",
    "updated_at": "2025-03-19T18:29:50Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/8207",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/8207",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/session-fixation",
      "severity": "warning",
      "description": "Failure to abandon session",
      "name": "js/session-fixation",
      "tags": [
        "external/cwe/cwe-384",
        "security"
      ],
      "full_description": "Reusing an existing session as a different user could allow an attacker to access someone else's account by using their session.",
      "help": "# Failure to abandon session\nReusing a session could allow an attacker to gain unauthorized access to another account. Always ensure that, when a user logs in or out, the current session is abandoned so that a new session may be started.\n\n\n## Recommendation\nAlways use `req.session.regenerate(...);` to start a new session when a user logs in or out.\n\n\n## Example\nThe following example shows the previous session being used after authentication. This would allow a previous user to use the new user's account.\n\n\n```javascript\nconst express = require('express');\nconst session = require('express-session');\nvar bodyParser = require('body-parser')\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }))\napp.use(session({\n    secret: 'keyboard cat'\n}));\n\napp.post('/login', function (req, res) {\n    // Check that username password matches\n    if (req.body.username === 'admin' && req.body.password === 'admin') {\n        req.session.authenticated = true;\n        res.redirect('/');\n    } else {\n        res.redirect('/login');\n    }\n});\n```\nThis code example solves the problem by not reusing the session, and instead calling `req.session.regenerate()` to ensure that the session is not reused.\n\n\n```javascript\nconst express = require('express');\nconst session = require('express-session');\nvar bodyParser = require('body-parser')\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }))\napp.use(session({\n    secret: 'keyboard cat'\n}));\n\napp.post('/login', function (req, res) {\n    // Check that username password matches\n    if (req.body.username === 'admin' && req.body.password === 'admin') {\n        req.session.regenerate(function (err) {\n            if (err) {\n                res.send('Error');\n            } else {\n                req.session.authenticated = true;\n                res.redirect('/');\n            }\n        });\n    } else {\n        res.redirect('/login');\n    }\n});\n```\n\n## References\n* OWASP: [Session fixation](https://www.owasp.org/index.php/Session_fixation)\n* Stack Overflow: [Creating a new session after authentication with Passport](https://stackoverflow.com/questions/22209354/creating-a-new-session-after-authentication-with-passport/30468384#30468384)\n* jscrambler.com: [Best practices for secure session management in Node](https://blog.jscrambler.com/best-practices-for-secure-session-management-in-node)\n* Common Weakness Enumeration: [CWE-384](https://cwe.mitre.org/data/definitions/384.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:javascript-typescript",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "Route handler does not invalidate session following login."
      },
      "location": {
        "path": "routes/login.js",
        "start_line": 19,
        "end_line": 42,
        "start_column": 1,
        "end_column": 3
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/8207/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 8206,
    "created_at": "2025-03-19T18:29:50Z",
    "updated_at": "2025-03-19T18:29:50Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/8206",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/8206",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/log-injection",
      "severity": "error",
      "description": "Log injection",
      "name": "js/log-injection",
      "tags": [
        "external/cwe/cwe-117",
        "security"
      ],
      "full_description": "Building log entries from user-controlled sources is vulnerable to insertion of forged log entries by a malicious user.",
      "help": "# Log injection\nIf unsanitized user input is written to a log entry, a malicious user may be able to forge new log entries.\n\nForgery can occur if a user provides some input with characters that are interpreted when the log output is displayed. If the log is displayed as a plain text file, then new line characters can be used by a malicious user. If the log is displayed as HTML, then arbitrary HTML may be included to spoof log entries.\n\n\n## Recommendation\nUser input should be suitably sanitized before it is logged.\n\nIf the log entries are in plain text then line breaks should be removed from user input, using `String.prototype.replace` or similar. Care should also be taken that user input is clearly marked in log entries.\n\nFor log entries that will be displayed in HTML, user input should be HTML-encoded before being logged, to prevent forgery and other forms of HTML injection.\n\n\n## Example\nIn the first example, a username, provided by the user, is logged using \\`console.info\\`. In the first case, it is logged without any sanitization. In the second case, the username is used to build an error that is logged using \\`console.error\\`. If a malicious user provides \\`username=Guest%0a\\[INFO\\]+User:+Admin%0a\\` as a username parameter, the log entry will be splitted in two different lines, where the second line will be \\`\\[INFO\\]+User:+Admin\\`.\n\n\n```javascript\nconst http = require('http');\nconst url = require('url');\n\nconst server = http.createServer((req, res) => {\n    let q = url.parse(req.url, true);\n\n    console.info(`[INFO] User: ${q.query.username}`); // BAD: User input logged as-is\n})\n\nserver.listen(3000, '127.0.0.1', () => {});\n\n```\nIn the second example, `String.prototype.replace` is used to ensure no line endings are present in the user input.\n\n\n```javascript\nconst http = require('http');\nconst url = require('url');\n\nconst server = http.createServer((req, res) => {\n    let q = url.parse(req.url, true);\n\n    // GOOD: remove newlines from user controlled input before logging\n    let username = q.query.username.replace(/\\n|\\r/g, \"\");\n\n    console.info(`[INFO] User: ${username}`);\n});\n\nserver.listen(3000, '127.0.0.1', () => {});\n\n```\n\n## References\n* OWASP: [Log Injection](https://www.owasp.org/index.php/Log_Injection).\n* Common Weakness Enumeration: [CWE-117](https://cwe.mitre.org/data/definitions/117.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:javascript-typescript",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "Log entry depends on a user-provided value."
      },
      "location": {
        "path": "routes/login.js",
        "start_line": 25,
        "end_line": 25,
        "start_column": 18,
        "end_column": 62
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/8206/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 8205,
    "created_at": "2025-03-19T18:29:26Z",
    "updated_at": "2025-03-19T18:29:26Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/8205",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/8205",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "actions/unpinned-tag",
      "severity": "warning",
      "description": "Unpinned tag for a non-immutable Action in workflow",
      "name": "actions/unpinned-tag",
      "tags": [
        "actions",
        "external/cwe/cwe-829",
        "security"
      ],
      "full_description": "Using a tag for a non-immutable Action that is not pinned to a commit can lead to executing an untrusted Action through a supply chain attack.",
      "help": "# Unpinned tag for 3rd party Action in workflow\n\n## Description\n\nUsing a tag for a 3rd party Action that is not pinned to a commit can lead to executing an untrusted Action through a supply chain attack.\n\n## Recommendations\n\nPinning an action to a full length commit SHA is currently the only way to use a non-immutable action as an immutable release. Pinning to a particular SHA helps mitigate the risk of a bad actor adding a backdoor to the action's repository, as they would need to generate a SHA-1 collision for a valid Git object payload. When selecting a SHA, you should verify it is from the action's repository and not a repository fork.\n\n## Examples\n\n### Incorrect Usage\n\n```yaml\n- uses: tj-actions/changed-files@v44\n```\n\n### Correct Usage\n\n```yaml\n- uses: tj-actions/changed-files@c65cd883420fd2eb864698a825fc4162dd94482c # v44\n```\n\n## References\n\n- [Using third-party actions](https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions#using-third-party-actions)",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:actions\",\"language\":\"actions\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:actions",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "Unpinned 3rd party Action 'trivy' step Uses Step uses 'aquasecurity/trivy-action' with ref '0.24.0', not a pinned commit hash"
      },
      "location": {
        "path": ".github/workflows/trivy.yml",
        "start_line": 37,
        "end_line": 37,
        "start_column": 15,
        "end_column": 47
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/8205/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 8204,
    "created_at": "2025-03-19T18:29:26Z",
    "updated_at": "2025-03-19T18:29:26Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/8204",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/8204",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "actions/unpinned-tag",
      "severity": "warning",
      "description": "Unpinned tag for a non-immutable Action in workflow",
      "name": "actions/unpinned-tag",
      "tags": [
        "actions",
        "external/cwe/cwe-829",
        "security"
      ],
      "full_description": "Using a tag for a non-immutable Action that is not pinned to a commit can lead to executing an untrusted Action through a supply chain attack.",
      "help": "# Unpinned tag for 3rd party Action in workflow\n\n## Description\n\nUsing a tag for a 3rd party Action that is not pinned to a commit can lead to executing an untrusted Action through a supply chain attack.\n\n## Recommendations\n\nPinning an action to a full length commit SHA is currently the only way to use a non-immutable action as an immutable release. Pinning to a particular SHA helps mitigate the risk of a bad actor adding a backdoor to the action's repository, as they would need to generate a SHA-1 collision for a valid Git object payload. When selecting a SHA, you should verify it is from the action's repository and not a repository fork.\n\n## Examples\n\n### Incorrect Usage\n\n```yaml\n- uses: tj-actions/changed-files@v44\n```\n\n### Correct Usage\n\n```yaml\n- uses: tj-actions/changed-files@c65cd883420fd2eb864698a825fc4162dd94482c # v44\n```\n\n## References\n\n- [Using third-party actions](https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions#using-third-party-actions)",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:actions\",\"language\":\"actions\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:actions",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "Unpinned 3rd party Action 'Codacy Security Scan' step Uses Step uses 'codacy/codacy-analysis-cli-action' with ref 'master', not a pinned commit hash"
      },
      "location": {
        "path": ".github/workflows/codacy.yml",
        "start_line": 18,
        "end_line": 18,
        "start_column": 15,
        "end_column": 55
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/8204/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 8203,
    "created_at": "2025-03-19T18:29:26Z",
    "updated_at": "2025-03-19T18:29:26Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/8203",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/8203",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "actions/missing-workflow-permissions",
      "severity": "warning",
      "description": "Workflow does not contain permissions",
      "name": "actions/missing-workflow-permissions",
      "tags": [
        "actions",
        "external/cwe/cwe-275",
        "maintainability",
        "security"
      ],
      "full_description": "Workflows should contain explicit permissions to restrict the scope of the default GITHUB_TOKEN.",
      "help": "# Actions Job and Workflow Permissions are not set\n\n## Description\n\nIf a GitHub Actions job or workflow has no explicit permissions set, then the repository permissions are used. Repositories created under organizations inherit the organization permissions. The organizations or repositories created before February 2023 have the default permissions set to read-write. Often these permissions do not adhere to the principle of least privilege and can be reduced to read-only, leaving the `write` permission only to a specific types as `issues: write` or `pull-requests: write`.\n\n## Recommendations\n\nAdd the `permissions` key to the job or the root of workflow (in this case it is applied to all jobs in the workflow that do not have their own `permissions` key) and assign the least privileges required to complete the task:\n\n```yaml\nname: \"My workflow\"\npermissions:\n  contents: read\n  pull-requests: write\n```\n\nor\n\n```yaml\njobs:\n  my-job:\n    permissions:\n      contents: read\n      pull-requests: write\n```\n\n## References\n\n- [Assigning permissions to jobs](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/assigning-permissions-to-jobs)\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:actions\",\"language\":\"actions\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:actions",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "Actions job or workflow does not limit the permissions of the GITHUB_TOKEN. Consider setting an explicit permissions block, using the following as a minimal starting point: {{contents: read}}"
      },
      "location": {
        "path": ".github/workflows/codacy.yml",
        "start_line": 11,
        "end_line": 39,
        "start_column": 5,
        "end_column": 37
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/8203/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 8202,
    "created_at": "2025-03-19T18:29:26Z",
    "updated_at": "2025-03-19T18:29:26Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/8202",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/8202",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "actions/missing-workflow-permissions",
      "severity": "warning",
      "description": "Workflow does not contain permissions",
      "name": "actions/missing-workflow-permissions",
      "tags": [
        "actions",
        "external/cwe/cwe-275",
        "maintainability",
        "security"
      ],
      "full_description": "Workflows should contain explicit permissions to restrict the scope of the default GITHUB_TOKEN.",
      "help": "# Actions Job and Workflow Permissions are not set\n\n## Description\n\nIf a GitHub Actions job or workflow has no explicit permissions set, then the repository permissions are used. Repositories created under organizations inherit the organization permissions. The organizations or repositories created before February 2023 have the default permissions set to read-write. Often these permissions do not adhere to the principle of least privilege and can be reduced to read-only, leaving the `write` permission only to a specific types as `issues: write` or `pull-requests: write`.\n\n## Recommendations\n\nAdd the `permissions` key to the job or the root of workflow (in this case it is applied to all jobs in the workflow that do not have their own `permissions` key) and assign the least privileges required to complete the task:\n\n```yaml\nname: \"My workflow\"\npermissions:\n  contents: read\n  pull-requests: write\n```\n\nor\n\n```yaml\njobs:\n  my-job:\n    permissions:\n      contents: read\n      pull-requests: write\n```\n\n## References\n\n- [Assigning permissions to jobs](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/assigning-permissions-to-jobs)\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:actions\",\"language\":\"actions\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:actions",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "Actions job or workflow does not limit the permissions of the GITHUB_TOKEN. Consider setting an explicit permissions block, using the following as a minimal starting point: {{}}"
      },
      "location": {
        "path": ".github/workflows/lscpu.yml",
        "start_line": 7,
        "end_line": 9,
        "start_column": 5,
        "end_column": 20
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/8202/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 27,
    "created_at": "2024-08-07T16:04:42Z",
    "updated_at": "2024-08-07T16:04:44Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/27",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/27",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/clear-text-cookie",
      "severity": "warning",
      "description": "Clear text transmission of sensitive cookie",
      "name": "js/clear-text-cookie",
      "tags": [
        "external/cwe/cwe-311",
        "external/cwe/cwe-312",
        "external/cwe/cwe-319",
        "external/cwe/cwe-614",
        "security"
      ],
      "full_description": "Sending sensitive information in a cookie without requring SSL encryption can expose the cookie to an attacker.",
      "help": "# Clear text transmission of sensitive cookie\nCookies that are transmitted in clear text can be intercepted by an attacker. If sensitive cookies are intercepted, the attacker can read the cookie and use it to perform actions on the user's behalf.\n\n\n## Recommendation\nAlways transmit sensitive cookies using SSL by setting the `secure` attribute on the cookie.\n\n\n## Example\nThe following example stores an authentication token in a cookie that can be transmitted in clear text.\n\n\n```javascript\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n    res.setHeader(\"Set-Cookie\", `authKey=${makeAuthkey()}`);\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.end('<h2>Hello world</h2>');\n});\n```\nTo force the cookie to be transmitted using SSL, set the `secure` attribute on the cookie.\n\n\n```javascript\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n    res.setHeader(\"Set-Cookie\", `authKey=${makeAuthkey()}; secure; httpOnly`);\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.end('<h2>Hello world</h2>');\n});\n```\n\n## References\n* ExpressJS: [Use cookies securely](https://expressjs.com/en/advanced/best-practice-security.html#use-cookies-securely).\n* OWASP: [Set cookie flags appropriately](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#set-cookie-flags-appropriately).\n* Mozilla: [Set-Cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie).\n* Common Weakness Enumeration: [CWE-614](https://cwe.mitre.org/data/definitions/614.html).\n* Common Weakness Enumeration: [CWE-311](https://cwe.mitre.org/data/definitions/311.html).\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:javascript-typescript",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "Sensitive cookie sent without enforcing SSL encryption."
      },
      "location": {
        "path": "app.js",
        "start_line": 43,
        "end_line": 49,
        "start_column": 9,
        "end_column": 3
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/27/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 22,
    "created_at": "2024-08-07T16:04:42Z",
    "updated_at": "2024-08-07T16:04:44Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/22",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/22",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/unsafe-jquery-plugin",
      "severity": "warning",
      "description": "Unsafe jQuery plugin",
      "name": "js/unsafe-jquery-plugin",
      "tags": [
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "frameworks/jquery",
        "security"
      ],
      "full_description": "A jQuery plugin that unintentionally constructs HTML from some of its options may be unsafe to use for clients.",
      "help": "# Unsafe jQuery plugin\nLibrary plugins, such as those for the jQuery library, are often configurable through options provided by the clients of the plugin. Clients, however, do not know the implementation details of the plugin, so it is important to document the capabilities of each option. The documentation for the plugin options that the client is responsible for sanitizing is of particular importance. Otherwise, the plugin may write user input (for example, a URL query parameter) to a web page without properly sanitizing it first, which allows for a cross-site scripting vulnerability in the client application through dynamic HTML construction.\n\n\n## Recommendation\nDocument all options that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.\n\n\n## Example\nThe following example shows a jQuery plugin that selects a DOM element, and copies its text content to another DOM element. The selection is performed by using the plugin option `sourceSelector` as a CSS selector.\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// BAD may evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\nThis is, however, not a safe plugin, since the call to `jQuery` interprets `sourceSelector` as HTML if it is a string that starts with `<`.\n\nInstead of documenting that the client is responsible for sanitizing `sourceSelector`, the plugin can use `jQuery.find` to always interpret `sourceSelector` as a CSS selector:\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// GOOD may not evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery.find(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* jQuery: [Plugin creation](https://learn.jquery.com/plugins/basic-plugin-creation/).\n* Bootstrap: [XSS vulnerable bootstrap plugins](https://github.com/twbs/bootstrap/pull/27047).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:javascript-typescript",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "Potential XSS vulnerability in the '$.fn.affix' plugin."
      },
      "location": {
        "path": "public/js/bootstrap.js",
        "start_line": 2220,
        "end_line": 2220,
        "start_column": 22,
        "end_column": 41
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/22/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 18,
    "created_at": "2024-08-07T16:04:42Z",
    "updated_at": "2024-08-07T16:04:44Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/18",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/18",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/unsafe-jquery-plugin",
      "severity": "warning",
      "description": "Unsafe jQuery plugin",
      "name": "js/unsafe-jquery-plugin",
      "tags": [
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "frameworks/jquery",
        "security"
      ],
      "full_description": "A jQuery plugin that unintentionally constructs HTML from some of its options may be unsafe to use for clients.",
      "help": "# Unsafe jQuery plugin\nLibrary plugins, such as those for the jQuery library, are often configurable through options provided by the clients of the plugin. Clients, however, do not know the implementation details of the plugin, so it is important to document the capabilities of each option. The documentation for the plugin options that the client is responsible for sanitizing is of particular importance. Otherwise, the plugin may write user input (for example, a URL query parameter) to a web page without properly sanitizing it first, which allows for a cross-site scripting vulnerability in the client application through dynamic HTML construction.\n\n\n## Recommendation\nDocument all options that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.\n\n\n## Example\nThe following example shows a jQuery plugin that selects a DOM element, and copies its text content to another DOM element. The selection is performed by using the plugin option `sourceSelector` as a CSS selector.\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// BAD may evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\nThis is, however, not a safe plugin, since the call to `jQuery` interprets `sourceSelector` as HTML if it is a string that starts with `<`.\n\nInstead of documenting that the client is responsible for sanitizing `sourceSelector`, the plugin can use `jQuery.find` to always interpret `sourceSelector` as a CSS selector:\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// GOOD may not evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery.find(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* jQuery: [Plugin creation](https://learn.jquery.com/plugins/basic-plugin-creation/).\n* Bootstrap: [XSS vulnerable bootstrap plugins](https://github.com/twbs/bootstrap/pull/27047).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:javascript-typescript",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "Potential XSS vulnerability in the '$.fn.tooltip' plugin."
      },
      "location": {
        "path": "public/js/bootstrap.js",
        "start_line": 1302,
        "end_line": 1302,
        "start_column": 49,
        "end_column": 194
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/18/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 13,
    "created_at": "2024-08-07T16:04:42Z",
    "updated_at": "2024-08-07T16:04:44Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/13",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/13",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/xss-through-dom",
      "severity": "warning",
      "description": "DOM text reinterpreted as HTML",
      "name": "js/xss-through-dom",
      "tags": [
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "security"
      ],
      "full_description": "Reinterpreting text from the DOM as HTML can lead to a cross-site scripting vulnerability.",
      "help": "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\nA webpage with this vulnerability reads text from the DOM, and afterwards adds the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes the text, and thereby invalidates any escaping done on the text. If an attacker is able to control the safe sanitized text, then this vulnerability can be exploited to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing text to the page, or one of the other solutions that are mentioned in the References section below.\n\n\n## Example\nThe following example shows a webpage using a `data-target` attribute to select and manipulate a DOM element using the JQuery library. In the example, the `data-target` attribute is read into the `target` variable, and the `$` function is then supposed to use the `target` variable as a CSS selector to determine which element should be manipulated.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can control the `data-target` attribute, then the value of `target` can be used to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability can be fixed by using `$.find` instead of `$`. The `$.find` function will only interpret `target` as a CSS selector and never as HTML, thereby preventing an XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:javascript-typescript",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "DOM text is reinterpreted as HTML without escaping meta-characters."
      },
      "location": {
        "path": "public/js/bootstrap.js",
        "start_line": 1557,
        "end_line": 1557,
        "start_column": 70,
        "end_column": 75
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/13/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 12,
    "created_at": "2024-08-07T16:04:42Z",
    "updated_at": "2024-08-07T16:04:44Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/12",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/12",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/xss-through-dom",
      "severity": "warning",
      "description": "DOM text reinterpreted as HTML",
      "name": "js/xss-through-dom",
      "tags": [
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "security"
      ],
      "full_description": "Reinterpreting text from the DOM as HTML can lead to a cross-site scripting vulnerability.",
      "help": "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\nA webpage with this vulnerability reads text from the DOM, and afterwards adds the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes the text, and thereby invalidates any escaping done on the text. If an attacker is able to control the safe sanitized text, then this vulnerability can be exploited to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing text to the page, or one of the other solutions that are mentioned in the References section below.\n\n\n## Example\nThe following example shows a webpage using a `data-target` attribute to select and manipulate a DOM element using the JQuery library. In the example, the `data-target` attribute is read into the `target` variable, and the `$` function is then supposed to use the `target` variable as a CSS selector to determine which element should be manipulated.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can control the `data-target` attribute, then the value of `target` can be used to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability can be fixed by using `$.find` instead of `$`. The `$.find` function will only interpret `target` as a CSS selector and never as HTML, thereby preventing an XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:javascript-typescript",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "DOM text is reinterpreted as HTML without escaping meta-characters."
      },
      "location": {
        "path": "public/js/bootstrap.js",
        "start_line": 1233,
        "end_line": 1233,
        "start_column": 21,
        "end_column": 94
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/12/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 11,
    "created_at": "2024-08-07T16:04:42Z",
    "updated_at": "2024-08-07T16:04:44Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/11",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/11",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/xss-through-dom",
      "severity": "warning",
      "description": "DOM text reinterpreted as HTML",
      "name": "js/xss-through-dom",
      "tags": [
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "security"
      ],
      "full_description": "Reinterpreting text from the DOM as HTML can lead to a cross-site scripting vulnerability.",
      "help": "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\nA webpage with this vulnerability reads text from the DOM, and afterwards adds the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes the text, and thereby invalidates any escaping done on the text. If an attacker is able to control the safe sanitized text, then this vulnerability can be exploited to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing text to the page, or one of the other solutions that are mentioned in the References section below.\n\n\n## Example\nThe following example shows a webpage using a `data-target` attribute to select and manipulate a DOM element using the JQuery library. In the example, the `data-target` attribute is read into the `target` variable, and the `$` function is then supposed to use the `target` variable as a CSS selector to determine which element should be manipulated.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can control the `data-target` attribute, then the value of `target` can be used to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability can be fixed by using `$.find` instead of `$`. The `$.find` function will only interpret `target` as a CSS selector and never as HTML, thereby preventing an XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:javascript-typescript",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "DOM text is reinterpreted as HTML without escaping meta-characters."
      },
      "location": {
        "path": "public/js/bootstrap.js",
        "start_line": 776,
        "end_line": 776,
        "start_column": 33,
        "end_column": 41
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/11/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 10,
    "created_at": "2024-08-07T16:04:42Z",
    "updated_at": "2024-08-07T16:04:44Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/10",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/10",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/xss-through-dom",
      "severity": "warning",
      "description": "DOM text reinterpreted as HTML",
      "name": "js/xss-through-dom",
      "tags": [
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "security"
      ],
      "full_description": "Reinterpreting text from the DOM as HTML can lead to a cross-site scripting vulnerability.",
      "help": "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\nA webpage with this vulnerability reads text from the DOM, and afterwards adds the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes the text, and thereby invalidates any escaping done on the text. If an attacker is able to control the safe sanitized text, then this vulnerability can be exploited to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing text to the page, or one of the other solutions that are mentioned in the References section below.\n\n\n## Example\nThe following example shows a webpage using a `data-target` attribute to select and manipulate a DOM element using the JQuery library. In the example, the `data-target` attribute is read into the `target` variable, and the `$` function is then supposed to use the `target` variable as a CSS selector to determine which element should be manipulated.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can control the `data-target` attribute, then the value of `target` can be used to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability can be fixed by using `$.find` instead of `$`. The `$.find` function will only interpret `target` as a CSS selector and never as HTML, thereby preventing an XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:javascript-typescript",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "DOM text is reinterpreted as HTML without escaping meta-characters."
      },
      "location": {
        "path": "public/js/bootstrap.js",
        "start_line": 694,
        "end_line": 694,
        "start_column": 14,
        "end_column": 20
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/10/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 9,
    "created_at": "2024-08-07T16:04:42Z",
    "updated_at": "2024-08-07T16:04:44Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/9",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/9",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/xss-through-dom",
      "severity": "warning",
      "description": "DOM text reinterpreted as HTML",
      "name": "js/xss-through-dom",
      "tags": [
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "security"
      ],
      "full_description": "Reinterpreting text from the DOM as HTML can lead to a cross-site scripting vulnerability.",
      "help": "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\nA webpage with this vulnerability reads text from the DOM, and afterwards adds the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes the text, and thereby invalidates any escaping done on the text. If an attacker is able to control the safe sanitized text, then this vulnerability can be exploited to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing text to the page, or one of the other solutions that are mentioned in the References section below.\n\n\n## Example\nThe following example shows a webpage using a `data-target` attribute to select and manipulate a DOM element using the JQuery library. In the example, the `data-target` attribute is read into the `target` variable, and the `$` function is then supposed to use the `target` variable as a CSS selector to determine which element should be manipulated.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can control the `data-target` attribute, then the value of `target` can be used to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability can be fixed by using `$.find` instead of `$`. The `$.find` function will only interpret `target` as a CSS selector and never as HTML, thereby preventing an XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:javascript-typescript",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "DOM text is reinterpreted as HTML without escaping meta-characters."
      },
      "location": {
        "path": "public/js/bootstrap.js",
        "start_line": 505,
        "end_line": 505,
        "start_column": 21,
        "end_column": 115
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/9/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 8,
    "created_at": "2024-08-07T16:04:42Z",
    "updated_at": "2024-08-07T16:04:44Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/8",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/8",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/xss-through-dom",
      "severity": "warning",
      "description": "DOM text reinterpreted as HTML",
      "name": "js/xss-through-dom",
      "tags": [
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "security"
      ],
      "full_description": "Reinterpreting text from the DOM as HTML can lead to a cross-site scripting vulnerability.",
      "help": "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\nA webpage with this vulnerability reads text from the DOM, and afterwards adds the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes the text, and thereby invalidates any escaping done on the text. If an attacker is able to control the safe sanitized text, then this vulnerability can be exploited to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing text to the page, or one of the other solutions that are mentioned in the References section below.\n\n\n## Example\nThe following example shows a webpage using a `data-target` attribute to select and manipulate a DOM element using the JQuery library. In the example, the `data-target` attribute is read into the `target` variable, and the `$` function is then supposed to use the `target` variable as a CSS selector to determine which element should be manipulated.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can control the `data-target` attribute, then the value of `target` can be used to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability can be fixed by using `$.find` instead of `$`. The `$.find` function will only interpret `target` as a CSS selector and never as HTML, thereby preventing an XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:javascript-typescript",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "DOM text is reinterpreted as HTML without escaping meta-characters."
      },
      "location": {
        "path": "public/js/bootstrap.js",
        "start_line": 112,
        "end_line": 112,
        "start_column": 21,
        "end_column": 29
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/8/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 7,
    "created_at": "2024-08-07T16:04:42Z",
    "updated_at": "2024-08-07T16:04:44Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/7",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/7",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/unsafe-html-expansion",
      "severity": "warning",
      "description": "Unsafe expansion of self-closing HTML tag",
      "name": "js/unsafe-html-expansion",
      "tags": [
        "correctness",
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "security"
      ],
      "full_description": "Using regular expressions to expand self-closing HTML tags may lead to cross-site scripting vulnerabilities.",
      "help": "# Unsafe expansion of self-closing HTML tag\nSanitizing untrusted input for HTML meta-characters is a common technique for preventing cross-site scripting attacks. But even a sanitized input can be dangerous to use if it is modified further before a browser treats it as HTML. A seemingly innocent transformation that expands a self-closing HTML tag from `<div attr=\"{sanitized}\"/>` to `<div attr=\"{sanitized}\"></div>` may in fact cause cross-site scripting vulnerabilities.\n\n\n## Recommendation\nUse a well-tested sanitization library if at all possible, and avoid modifying sanitized values further before treating them as HTML.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using HTML templates that are explicit about the values they treat as HTML.\n\n\n## Example\nThe following function transforms a self-closing HTML tag to a pair of open/close tags. It does so for all non-`img` and non-`area` tags, by using a regular expression with two capture groups. The first capture group corresponds to the name of the tag, and the second capture group to the content of the tag.\n\n\n```javascript\nfunction expandSelfClosingTags(html) {\n\tvar rxhtmlTag = /<(?!img|area)(([a-z][^\\w\\/>]*)[^>]*)\\/>/gi;\n\treturn html.replace(rxhtmlTag, \"<$1></$2>\"); // BAD\n}\n\n```\nWhile it is generally known regular expressions are ill-suited for parsing HTML, variants of this particular transformation pattern have long been considered safe.\n\nHowever, the function is not safe. As an example, consider the following string:\n\n\n```html\n<div alt=\"\n<x\" title=\"/>\n<img src=url404 onerror=alert(1)>\"/>\n\n```\nWhen the above function transforms the string, it becomes a string that results in an alert when a browser treats it as HTML.\n\n\n```html\n<div alt=\"\n<x\" title=\"></x\" >\n<img src=url404 onerror=alert(1)>\"/>\n\n```\n\n## References\n* jQuery: [Security fixes in jQuery 3.5.0](https://blog.jquery.com/2020/04/10/jquery-3-5-0-released/)\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [Types of Cross-Site](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:javascript-typescript",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "This self-closing HTML tag expansion invalidates prior sanitization as this regular expression may match part of an attribute value."
      },
      "location": {
        "path": "public/js/jquery.js",
        "start_line": 3,
        "end_line": 3,
        "start_column": 21896,
        "end_column": 21921
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/7/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 6,
    "created_at": "2024-08-07T16:04:42Z",
    "updated_at": "2024-08-07T16:04:44Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/6",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/6",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/unsafe-html-expansion",
      "severity": "warning",
      "description": "Unsafe expansion of self-closing HTML tag",
      "name": "js/unsafe-html-expansion",
      "tags": [
        "correctness",
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "security"
      ],
      "full_description": "Using regular expressions to expand self-closing HTML tags may lead to cross-site scripting vulnerabilities.",
      "help": "# Unsafe expansion of self-closing HTML tag\nSanitizing untrusted input for HTML meta-characters is a common technique for preventing cross-site scripting attacks. But even a sanitized input can be dangerous to use if it is modified further before a browser treats it as HTML. A seemingly innocent transformation that expands a self-closing HTML tag from `<div attr=\"{sanitized}\"/>` to `<div attr=\"{sanitized}\"></div>` may in fact cause cross-site scripting vulnerabilities.\n\n\n## Recommendation\nUse a well-tested sanitization library if at all possible, and avoid modifying sanitized values further before treating them as HTML.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using HTML templates that are explicit about the values they treat as HTML.\n\n\n## Example\nThe following function transforms a self-closing HTML tag to a pair of open/close tags. It does so for all non-`img` and non-`area` tags, by using a regular expression with two capture groups. The first capture group corresponds to the name of the tag, and the second capture group to the content of the tag.\n\n\n```javascript\nfunction expandSelfClosingTags(html) {\n\tvar rxhtmlTag = /<(?!img|area)(([a-z][^\\w\\/>]*)[^>]*)\\/>/gi;\n\treturn html.replace(rxhtmlTag, \"<$1></$2>\"); // BAD\n}\n\n```\nWhile it is generally known regular expressions are ill-suited for parsing HTML, variants of this particular transformation pattern have long been considered safe.\n\nHowever, the function is not safe. As an example, consider the following string:\n\n\n```html\n<div alt=\"\n<x\" title=\"/>\n<img src=url404 onerror=alert(1)>\"/>\n\n```\nWhen the above function transforms the string, it becomes a string that results in an alert when a browser treats it as HTML.\n\n\n```html\n<div alt=\"\n<x\" title=\"></x\" >\n<img src=url404 onerror=alert(1)>\"/>\n\n```\n\n## References\n* jQuery: [Security fixes in jQuery 3.5.0](https://blog.jquery.com/2020/04/10/jquery-3-5-0-released/)\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [Types of Cross-Site](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:javascript-typescript",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "This self-closing HTML tag expansion invalidates prior sanitization as this regular expression may match part of an attribute value."
      },
      "location": {
        "path": "public/js/jquery.js",
        "start_line": 3,
        "end_line": 3,
        "start_column": 19206,
        "end_column": 19231
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/6/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 3,
    "created_at": "2024-08-07T16:04:42Z",
    "updated_at": "2024-08-07T16:04:44Z",
    "url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/3",
    "html_url": "https://github.com/octodemo/vulnerable-node/security/code-scanning/3",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/server-side-unvalidated-url-redirection",
      "severity": "warning",
      "description": "Server-side URL redirect",
      "name": "js/server-side-unvalidated-url-redirection",
      "tags": [
        "external/cwe/cwe-601",
        "security"
      ],
      "full_description": "Server-side URL redirection based on unvalidated user input may cause redirection to malicious web sites.",
      "help": "# Server-side URL redirect\nDirectly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.\n\n\n## Recommendation\nTo guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.\n\nIf this is not possible, then the user input should be validated in some other way, for example, by verifying that the target URL is on the same host as the current page.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks:\n\n\n```javascript\nconst app = require(\"express\")();\n\napp.get(\"/redirect\", function (req, res) {\n  // BAD: a request parameter is incorporated without validation into a URL redirect\n  res.redirect(req.query[\"target\"]);\n});\n\n```\nOne way to remedy the problem is to validate the user input against a known fixed string before doing the redirection:\n\n\n```javascript\nconst app = require(\"express\")();\n\nconst VALID_REDIRECT = \"http://cwe.mitre.org/data/definitions/601.html\";\n\napp.get(\"/redirect\", function (req, res) {\n  // GOOD: the request parameter is validated against a known fixed string\n  let target = req.query[\"target\"];\n  if (VALID_REDIRECT === target) {\n    res.redirect(target);\n  } else {\n    res.redirect(\"/\");\n  }\n});\n\n```\nAlternatively, we can check that the target URL does not redirect to a different host by parsing it relative to a base URL with a known host and verifying that the host stays the same:\n\n\n```javascript\nconst app = require(\"express\")();\n\nfunction isLocalUrl(path) {\n  try {\n    return (\n      // TODO: consider substituting your own domain for example.com\n      new URL(path, \"https://example.com\").origin === \"https://example.com\"\n    );\n  } catch (e) {\n    return false;\n  }\n}\n\napp.get(\"/redirect\", function (req, res) {\n  // GOOD: check that we don't redirect to a different host\n  let target = req.query[\"target\"];\n  if (isLocalUrl(target)) {\n    res.redirect(target);\n  } else {\n    res.redirect(\"/\");\n  }\n});\n\n```\nNote that as written, the above code will allow redirects to URLs on `example.com`, which is harmless but perhaps not intended. You can substitute your own domain (if known) for `example.com` to prevent this.\n\n\n## References\n* OWASP: [ XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.21.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/master",
      "analysis_key": "dynamic/github-code-scanning/codeql:analyze",
      "environment": "{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-22.04\\\"]\"}",
      "category": "/language:javascript-typescript",
      "state": "open",
      "commit_sha": "e4eff27b03cb70efb01ed527efafd1d66f5b2604",
      "message": {
        "text": "Untrusted URL redirection depends on a user-provided value."
      },
      "location": {
        "path": "routes/login.js",
        "start_line": 36,
        "end_line": 36,
        "start_column": 26,
        "end_column": 35
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/octodemo/vulnerable-node/code-scanning/alerts/3/instances",
    "dismissal_approved_by": null
  }
]