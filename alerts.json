[
  {
    "number": 37,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/37",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/37",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/hardcoded-credentials",
      "severity": "warning",
      "description": "Hard-coded credentials",
      "name": "js/hardcoded-credentials",
      "tags": [
        "external/cwe/cwe-259",
        "external/cwe/cwe-321",
        "external/cwe/cwe-798",
        "security"
      ],
      "full_description": "Hard-coding credentials in source code may enable an attacker to gain unauthorized access.",
      "help": "# Hard-coded credentials\nIncluding unencrypted hard-coded authentication credentials in source code is dangerous because the credentials may be easily discovered. For example, the code may be open source, or it may be leaked or accidentally revealed, making the credentials visible to an attacker. This, in turn, might enable them to gain unauthorized access, or to obtain privileged information.\n\n\n## Recommendation\nRemove hard-coded credentials, such as user names, passwords and certificates, from source code. Instead, place them in configuration files, environment variables or other data stores if necessary. If possible, store configuration files including credential data separately from the source code, in a secure location with restricted access.\n\n\n## Example\nThe following code example connects to a Postgres database using the `pg` package and hard-codes user name and password:\n\n\n```javascript\nconst pg = require(\"pg\");\n\nconst client = new pg.Client({\n  user: \"bob\",\n  host: \"database.server.com\",\n  database: \"mydb\",\n  password: \"correct-horse-battery-staple\",\n  port: 3211\n});\nclient.connect();\n\n```\nInstead, user name and password can be supplied through the environment variables `PGUSER` and `PGPASSWORD`, which can be set externally without hard-coding credentials in the source code.\n\n\n## References\n* OWASP: [Use of hard-coded password](https://www.owasp.org/index.php/Use_of_hard-coded_password).\n* Common Weakness Enumeration: [CWE-259](https://cwe.mitre.org/data/definitions/259.html).\n* Common Weakness Enumeration: [CWE-321](https://cwe.mitre.org/data/definitions/321.html).\n* Common Weakness Enumeration: [CWE-798](https://cwe.mitre.org/data/definitions/798.html).\n",
      "security_severity_level": "critical"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "The hard-coded value \"Ã±asddfilhpaf78h78032h780g780fg780asg780dsbovncubuyvqy\" is used as key."
      },
      "location": {
        "path": "app.js",
        "start_line": 44,
        "end_line": 44,
        "start_column": 11,
        "end_column": 66
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/37/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 36,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/36",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/36",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/missing-rate-limiting",
      "severity": "warning",
      "description": "Missing rate limiting",
      "name": "js/missing-rate-limiting",
      "tags": [
        "external/cwe/cwe-307",
        "external/cwe/cwe-400",
        "external/cwe/cwe-770",
        "security"
      ],
      "full_description": "An HTTP request handler that performs expensive operations without restricting the rate at which operations can be carried out is vulnerable to denial-of-service attacks.",
      "help": "# Missing rate limiting\nHTTP request handlers should not perform expensive operations such as accessing the file system, executing an operating system command or interacting with a database without limiting the rate at which requests are accepted. Otherwise, the application becomes vulnerable to denial-of-service attacks where an attacker can cause the application to crash or become unresponsive by issuing a large number of requests at the same time.\n\n\n## Recommendation\nA rate-limiting middleware should be used to prevent such attacks.\n\n\n## Example\nThe following example shows an Express application that serves static files without rate limiting:\n\n\n```javascript\nvar express = require('express');\nvar app = express();\n\napp.get('/:path', function(req, res) {\n  let path = req.params.path;\n  if (isValidPath(path))\n    res.sendFile(path);\n});\n\n```\nTo prevent denial-of-service attacks, the `express-rate-limit` package can be used:\n\n\n```javascript\nvar express = require('express');\nvar app = express();\n\n// set up rate limiter: maximum of five requests per minute\nvar RateLimit = require('express-rate-limit');\nvar limiter = RateLimit({\n  windowMs: 1*60*1000, // 1 minute\n  max: 5\n});\n\n// apply rate limiter to all requests\napp.use(limiter);\n\napp.get('/:path', function(req, res) {\n  let path = req.params.path;\n  if (isValidPath(path))\n    res.sendFile(path);\n});\n\n```\n\n## References\n* OWASP: [Denial of Service Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html).\n* Wikipedia: [Denial-of-service attack](https://en.wikipedia.org/wiki/Denial-of-service_attack).\n* NPM: [express-rate-limit](https://www.npmjs.com/package/express-rate-limit).\n* Common Weakness Enumeration: [CWE-770](https://cwe.mitre.org/data/definitions/770.html).\n* Common Weakness Enumeration: [CWE-307](https://cwe.mitre.org/data/definitions/307.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "This route handler performs authorization, but is not rate-limited."
      },
      "location": {
        "path": "routes/login.js",
        "start_line": 19,
        "end_line": 42,
        "start_column": 28,
        "end_column": 2
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/36/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 33,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/33",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/33",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/missing-token-validation",
      "severity": "error",
      "description": "Missing CSRF middleware",
      "name": "js/missing-token-validation",
      "tags": [
        "external/cwe/cwe-352",
        "security"
      ],
      "full_description": "Using cookies without CSRF protection may allow malicious websites to submit requests on behalf of the user.",
      "help": "# Missing CSRF middleware\nWebsites that rely on cookie-based authentication may be vulnerable to cross-site request forgery (CSRF). Specifically, a state-changing request should include a secret token so the request can't be forged by an attacker. Otherwise, unwanted requests can be submitted on behalf of a user who visits a malicious website.\n\nThis is typically mitigated by embedding a session-specific secret token in each request. This token is then checked as an additional authentication measure. A malicious website should have no way of guessing the correct token to embed in the request.\n\n\n## Recommendation\nUse a middleware package such as `lusca.csrf` to protect against CSRF attacks.\n\n\n## Example\nIn the example below, the server authenticates users before performing the `changeEmail` POST action:\n\n\n```javascript\nconst app = require(\"express\")(),\n  cookieParser = require(\"cookie-parser\"),\n  bodyParser = require(\"body-parser\"),\n  session = require(\"express-session\");\n\napp.use(cookieParser());\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(session({ secret: process.env['SECRET'], cookie: { maxAge: 60000 } }));\n\n// ...\n\napp.post(\"/changeEmail\", function(req, res) {\n  const userId = req.session.id;\n  const email = req.body[\"email\"];\n  // ... update email associated with userId\n});\n\n```\nThis is not secure. An attacker can submit a POST `changeEmail` request on behalf of a user who visited a malicious website. Since authentication happens without any action from the user, the `changeEmail` action would be executed, despite not being initiated by the user.\n\nThis vulnerability can be mitigated by installing a CSRF protecting middleware handler:\n\n\n```javascript\nconst app = require(\"express\")(),\n  cookieParser = require(\"cookie-parser\"),\n  bodyParser = require(\"body-parser\"),\n  session = require(\"express-session\"),\n  csrf = require('lusca').csrf;\n\napp.use(cookieParser());\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(session({ secret: process.env['SECRET'], cookie: { maxAge: 60000 } }));\napp.use(csrf());\n\n// ...\n\napp.post(\"/changeEmail\", function(req, res) {\n  const userId = req.session.id;\n  const email = req.body[\"email\"];\n  // ... update email associated with userId\n});\n\n```\n\n## References\n* OWASP: [Cross-Site Request Forgery (CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))\n* NPM: [lusca](https://www.npmjs.com/package/lusca)\n* Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "This cookie middleware is serving a request handler without CSRF protection."
      },
      "location": {
        "path": "app.js",
        "start_line": 41,
        "end_line": 41,
        "start_column": 9,
        "end_column": 23
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/33/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 30,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/30",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/30",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/sql-injection",
      "severity": "error",
      "description": "Database query built from user-controlled sources",
      "name": "js/sql-injection",
      "tags": [
        "external/cwe/cwe-089",
        "external/cwe/cwe-090",
        "external/cwe/cwe-943",
        "security"
      ],
      "full_description": "Building a database query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
      "help": "# Database query built from user-controlled sources\nIf a database query (such as a SQL or NoSQL query) is built from user-provided data without sufficient sanitization, a malicious user may be able to run malicious database queries.\n\n\n## Recommendation\nMost database connector libraries offer a way of safely embedding untrusted data into a query by means of query parameters or prepared statements.\n\nFor NoSQL queries, make use of an operator like MongoDB's `$eq` to ensure that untrusted data is interpreted as a literal value and not as a query object.\n\n\n## Example\nIn the following example, assume the function `handler` is an HTTP request handler in a web application, whose parameter `req` contains the request object.\n\nThe handler constructs two copies of the same SQL query involving user input taken from the request object, once unsafely using string concatenation, and once safely using query parameters.\n\nIn the first case, the query string `query1` is built by directly concatenating a user-supplied request parameter with some string literals. The parameter may include quote characters, so this code is vulnerable to a SQL injection attack.\n\nIn the second case, the parameter is embedded into the query string `query2` using query parameters. In this example, we use the API offered by the `pg` Postgres database connector library, but other libraries offer similar features. This version is immune to injection attacks.\n\n\n```javascript\nconst app = require(\"express\")(),\n      pg = require(\"pg\"),\n      pool = new pg.Pool(config);\n\napp.get(\"search\", function handler(req, res) {\n  // BAD: the category might have SQL special characters in it\n  var query1 =\n    \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\" +\n    req.params.category +\n    \"' ORDER BY PRICE\";\n  pool.query(query1, [], function(err, results) {\n    // process results\n  });\n\n  // GOOD: use parameters\n  var query2 =\n    \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=$1\" + \" ORDER BY PRICE\";\n  pool.query(query2, [req.params.category], function(err, results) {\n    // process results\n  });\n});\n\n```\n\n## References\n* Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).\n* MongoDB: [$eq operator](https://docs.mongodb.com/manual/reference/operator/query/eq).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).\n* Common Weakness Enumeration: [CWE-943](https://cwe.mitre.org/data/definitions/943.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "This query depends on a user-provided value.\nThis query depends on a user-provided value."
      },
      "location": {
        "path": "model/products.js",
        "start_line": 40,
        "end_line": 40,
        "start_column": 19,
        "end_column": 20
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/30/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 29,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/29",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/29",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/sql-injection",
      "severity": "error",
      "description": "Database query built from user-controlled sources",
      "name": "js/sql-injection",
      "tags": [
        "external/cwe/cwe-089",
        "external/cwe/cwe-090",
        "external/cwe/cwe-943",
        "security"
      ],
      "full_description": "Building a database query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
      "help": "# Database query built from user-controlled sources\nIf a database query (such as a SQL or NoSQL query) is built from user-provided data without sufficient sanitization, a malicious user may be able to run malicious database queries.\n\n\n## Recommendation\nMost database connector libraries offer a way of safely embedding untrusted data into a query by means of query parameters or prepared statements.\n\nFor NoSQL queries, make use of an operator like MongoDB's `$eq` to ensure that untrusted data is interpreted as a literal value and not as a query object.\n\n\n## Example\nIn the following example, assume the function `handler` is an HTTP request handler in a web application, whose parameter `req` contains the request object.\n\nThe handler constructs two copies of the same SQL query involving user input taken from the request object, once unsafely using string concatenation, and once safely using query parameters.\n\nIn the first case, the query string `query1` is built by directly concatenating a user-supplied request parameter with some string literals. The parameter may include quote characters, so this code is vulnerable to a SQL injection attack.\n\nIn the second case, the parameter is embedded into the query string `query2` using query parameters. In this example, we use the API offered by the `pg` Postgres database connector library, but other libraries offer similar features. This version is immune to injection attacks.\n\n\n```javascript\nconst app = require(\"express\")(),\n      pg = require(\"pg\"),\n      pool = new pg.Pool(config);\n\napp.get(\"search\", function handler(req, res) {\n  // BAD: the category might have SQL special characters in it\n  var query1 =\n    \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\" +\n    req.params.category +\n    \"' ORDER BY PRICE\";\n  pool.query(query1, [], function(err, results) {\n    // process results\n  });\n\n  // GOOD: use parameters\n  var query2 =\n    \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=$1\" + \" ORDER BY PRICE\";\n  pool.query(query2, [req.params.category], function(err, results) {\n    // process results\n  });\n});\n\n```\n\n## References\n* Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).\n* MongoDB: [$eq operator](https://docs.mongodb.com/manual/reference/operator/query/eq).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).\n* Common Weakness Enumeration: [CWE-943](https://cwe.mitre.org/data/definitions/943.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "This query depends on a user-provided value."
      },
      "location": {
        "path": "model/products.js",
        "start_line": 23,
        "end_line": 23,
        "start_column": 20,
        "end_column": 21
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/29/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 28,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/28",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/28",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/sql-injection",
      "severity": "error",
      "description": "Database query built from user-controlled sources",
      "name": "js/sql-injection",
      "tags": [
        "external/cwe/cwe-089",
        "external/cwe/cwe-090",
        "external/cwe/cwe-943",
        "security"
      ],
      "full_description": "Building a database query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
      "help": "# Database query built from user-controlled sources\nIf a database query (such as a SQL or NoSQL query) is built from user-provided data without sufficient sanitization, a malicious user may be able to run malicious database queries.\n\n\n## Recommendation\nMost database connector libraries offer a way of safely embedding untrusted data into a query by means of query parameters or prepared statements.\n\nFor NoSQL queries, make use of an operator like MongoDB's `$eq` to ensure that untrusted data is interpreted as a literal value and not as a query object.\n\n\n## Example\nIn the following example, assume the function `handler` is an HTTP request handler in a web application, whose parameter `req` contains the request object.\n\nThe handler constructs two copies of the same SQL query involving user input taken from the request object, once unsafely using string concatenation, and once safely using query parameters.\n\nIn the first case, the query string `query1` is built by directly concatenating a user-supplied request parameter with some string literals. The parameter may include quote characters, so this code is vulnerable to a SQL injection attack.\n\nIn the second case, the parameter is embedded into the query string `query2` using query parameters. In this example, we use the API offered by the `pg` Postgres database connector library, but other libraries offer similar features. This version is immune to injection attacks.\n\n\n```javascript\nconst app = require(\"express\")(),\n      pg = require(\"pg\"),\n      pool = new pg.Pool(config);\n\napp.get(\"search\", function handler(req, res) {\n  // BAD: the category might have SQL special characters in it\n  var query1 =\n    \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\" +\n    req.params.category +\n    \"' ORDER BY PRICE\";\n  pool.query(query1, [], function(err, results) {\n    // process results\n  });\n\n  // GOOD: use parameters\n  var query2 =\n    \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=$1\" + \" ORDER BY PRICE\";\n  pool.query(query2, [req.params.category], function(err, results) {\n    // process results\n  });\n});\n\n```\n\n## References\n* Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).\n* MongoDB: [$eq operator](https://docs.mongodb.com/manual/reference/operator/query/eq).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).\n* Common Weakness Enumeration: [CWE-943](https://cwe.mitre.org/data/definitions/943.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "This query depends on a user-provided value."
      },
      "location": {
        "path": "model/products.js",
        "start_line": 16,
        "end_line": 16,
        "start_column": 19,
        "end_column": 20
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/28/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 27,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/27",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/27",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/sql-injection",
      "severity": "error",
      "description": "Database query built from user-controlled sources",
      "name": "js/sql-injection",
      "tags": [
        "external/cwe/cwe-089",
        "external/cwe/cwe-090",
        "external/cwe/cwe-943",
        "security"
      ],
      "full_description": "Building a database query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
      "help": "# Database query built from user-controlled sources\nIf a database query (such as a SQL or NoSQL query) is built from user-provided data without sufficient sanitization, a malicious user may be able to run malicious database queries.\n\n\n## Recommendation\nMost database connector libraries offer a way of safely embedding untrusted data into a query by means of query parameters or prepared statements.\n\nFor NoSQL queries, make use of an operator like MongoDB's `$eq` to ensure that untrusted data is interpreted as a literal value and not as a query object.\n\n\n## Example\nIn the following example, assume the function `handler` is an HTTP request handler in a web application, whose parameter `req` contains the request object.\n\nThe handler constructs two copies of the same SQL query involving user input taken from the request object, once unsafely using string concatenation, and once safely using query parameters.\n\nIn the first case, the query string `query1` is built by directly concatenating a user-supplied request parameter with some string literals. The parameter may include quote characters, so this code is vulnerable to a SQL injection attack.\n\nIn the second case, the parameter is embedded into the query string `query2` using query parameters. In this example, we use the API offered by the `pg` Postgres database connector library, but other libraries offer similar features. This version is immune to injection attacks.\n\n\n```javascript\nconst app = require(\"express\")(),\n      pg = require(\"pg\"),\n      pool = new pg.Pool(config);\n\napp.get(\"search\", function handler(req, res) {\n  // BAD: the category might have SQL special characters in it\n  var query1 =\n    \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\" +\n    req.params.category +\n    \"' ORDER BY PRICE\";\n  pool.query(query1, [], function(err, results) {\n    // process results\n  });\n\n  // GOOD: use parameters\n  var query2 =\n    \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=$1\" + \" ORDER BY PRICE\";\n  pool.query(query2, [req.params.category], function(err, results) {\n    // process results\n  });\n});\n\n```\n\n## References\n* Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).\n* MongoDB: [$eq operator](https://docs.mongodb.com/manual/reference/operator/query/eq).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).\n* Common Weakness Enumeration: [CWE-943](https://cwe.mitre.org/data/definitions/943.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "This query depends on a user-provided value.\nThis query depends on a user-provided value."
      },
      "location": {
        "path": "model/auth.js",
        "start_line": 9,
        "end_line": 9,
        "start_column": 19,
        "end_column": 20
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/27/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 11,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/11",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/11",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/redos",
      "severity": "error",
      "description": "Inefficient regular expression",
      "name": "js/redos",
      "tags": [
        "external/cwe/cwe-1333",
        "external/cwe/cwe-400",
        "external/cwe/cwe-730",
        "security"
      ],
      "full_description": "A regular expression that requires exponential time to match certain inputs can be a performance bottleneck, and may be vulnerable to denial-of-service attacks.",
      "help": "# Inefficient regular expression\nSome regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting an expensive input string for the regular expression to match.\n\nThe regular expression engines provided by many popular JavaScript platforms use backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.\n\nTypically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.\n\n\n## Recommendation\nModify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter.\n\n\n## Example\nConsider this regular expression:\n\n```javascript\n\n\t\t\t/^_(__|.)+_$/\n\t\t\n```\nIts sub-expression `\"(__|.)+?\"` can match the string `\"__\"` either by the first alternative `\"__\"` to the left of the `\"|\"` operator, or by two repetitions of the second alternative `\".\"` to the right. Thus, a string consisting of an odd number of underscores followed by some other character will cause the regular expression engine to run for an exponential amount of time before rejecting the input.\n\nThis problem can be avoided by rewriting the regular expression to remove the ambiguity between the two branches of the alternative inside the repetition:\n\n```javascript\n\n\t\t\t/^_(__|[^_])+_$/\n\t\t\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](http://www.cs.bham.ac.uk/~hxt/research/reg-exp-sec.pdf).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "This part of the regular expression may cause exponential backtracking on strings starting with '0' and containing many repetitions of '0'."
      },
      "location": {
        "path": "routes/products.js",
        "start_line": 120,
        "end_line": 120,
        "start_column": 48,
        "end_column": 60
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/11/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 10,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/10",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/10",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/polynomial-redos",
      "severity": "warning",
      "description": "Polynomial regular expression used on uncontrolled data",
      "name": "js/polynomial-redos",
      "tags": [
        "external/cwe/cwe-1333",
        "external/cwe/cwe-400",
        "external/cwe/cwe-730",
        "security"
      ],
      "full_description": "A regular expression that can require polynomial time to match may be vulnerable to denial-of-service attacks.",
      "help": "# Polynomial regular expression used on uncontrolled data\nSome regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting an expensive input string for the regular expression to match.\n\nThe regular expression engines provided by many popular JavaScript platforms use backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.\n\nTypically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.\n\n\n## Recommendation\nModify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter.\n\n\n## Example\nConsider this use of a regular expression, which removes all leading and trailing whitespace in a string:\n\n```javascript\n\n\t\t\ttext.replace(/^\\s+|\\s+$/g, ''); // BAD\n\t\t\n```\nThe sub-expression `\"\\s+$\"` will match the whitespace characters in `text` from left to right, but it can start matching anywhere within a whitespace sequence. This is problematic for strings that do **not** end with a whitespace character. Such a string will force the regular expression engine to process each whitespace sequence once per whitespace character in the sequence.\n\nThis ultimately means that the time cost of trimming a string is quadratic in the length of the string. So a string like `\"a b\"` will take milliseconds to process, but a similar string with a million spaces instead of just one will take several minutes.\n\nAvoid this problem by rewriting the regular expression to not contain the ambiguity about when to start matching whitespace sequences. For instance, by using a negative look-behind (`/^\\s+|(?<!\\s)\\s+$/g`), or just by using the built-in trim method (`text.trim()`).\n\nNote that the sub-expression `\"^\\s+\"` is **not** problematic as the `^` anchor restricts when that sub-expression can start matching, and as the regular expression engine matches from left to right.\n\n\n## Example\nAs a similar, but slightly subtler problem, consider the regular expression that matches lines with numbers, possibly written using scientific notation:\n\n```javascript\n\n\t\t\t/^0\\.\\d+E?\\d+$/.test(str) // BAD\n\t\t\n```\nThe problem with this regular expression is in the sub-expression `\\d+E?\\d+` because the second `\\d+` can start matching digits anywhere after the first match of the first `\\d+` if there is no `E` in the input string.\n\nThis is problematic for strings that do **not** end with a digit. Such a string will force the regular expression engine to process each digit sequence once per digit in the sequence, again leading to a quadratic time complexity.\n\nTo make the processing faster, the regular expression should be rewritten such that the two `\\d+` sub-expressions do not have overlapping matches: `^0\\.\\d+(E\\d+)?$`.\n\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](http://www.cs.bham.ac.uk/~hxt/research/reg-exp-sec.pdf).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "This regular expression that depends on a user-provided value may run slow on strings starting with '0' and with many repetitions of '0'.\nThis regular expression that depends on a user-provided value may run slow on strings starting with '0' and with many repetitions of '0'."
      },
      "location": {
        "path": "routes/products.js",
        "start_line": 121,
        "end_line": 121,
        "start_column": 14,
        "end_column": 32
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/10/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 35,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/35",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/35",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/clear-text-cookie",
      "severity": "warning",
      "description": "Clear text transmission of sensitive cookie",
      "name": "js/clear-text-cookie",
      "tags": [
        "external/cwe/cwe-311",
        "external/cwe/cwe-312",
        "external/cwe/cwe-319",
        "external/cwe/cwe-614",
        "security"
      ],
      "full_description": "Sending sensitive information in a cookie without requring SSL encryption can expose the cookie to an attacker.",
      "help": "# Clear text transmission of sensitive cookie\nCookies that are transmitted in clear text can be intercepted by an attacker. If sensitive cookies are intercepted, the attacker can read the cookie and use it to perform actions on the user's behalf.\n\n\n## Recommendation\nAlways transmit sensitive cookies using SSL by setting the `secure` attribute on the cookie.\n\n\n## Example\nThe following example stores an authentication token in a cookie that can be transmitted in clear text.\n\n\n```javascript\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n    res.setHeader(\"Set-Cookie\", `authKey=${makeAuthkey()}`);\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.end('<h2>Hello world</h2>');\n});\n```\nTo force the cookie to be transmitted using SSL, set the `secure` attribute on the cookie.\n\n\n```javascript\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n    res.setHeader(\"Set-Cookie\", `authKey=${makeAuthkey()}; secure; httpOnly`);\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.end('<h2>Hello world</h2>');\n});\n```\n\n## References\n* ExpressJS: [Use cookies securely](https://expressjs.com/en/advanced/best-practice-security.html#use-cookies-securely).\n* OWASP: [Set cookie flags appropriately](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#set-cookie-flags-appropriately).\n* Mozilla: [Set-Cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie).\n* Common Weakness Enumeration: [CWE-614](https://cwe.mitre.org/data/definitions/614.html).\n* Common Weakness Enumeration: [CWE-311](https://cwe.mitre.org/data/definitions/311.html).\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "Sensitive cookie sent without enforcing SSL encryption."
      },
      "location": {
        "path": "app.js",
        "start_line": 43,
        "end_line": 49,
        "start_column": 9,
        "end_column": 3
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/35/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 34,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/34",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/34",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/server-side-unvalidated-url-redirection",
      "severity": "warning",
      "description": "Server-side URL redirect",
      "name": "js/server-side-unvalidated-url-redirection",
      "tags": [
        "external/cwe/cwe-601",
        "security"
      ],
      "full_description": "Server-side URL redirection based on unvalidated user input may cause redirection to malicious web sites.",
      "help": "# Server-side URL redirect\nDirectly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.\n\n\n## Recommendation\nTo guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks:\n\n\n```javascript\nconst app = require(\"express\")();\n\napp.get('/some/path', function(req, res) {\n  // BAD: a request parameter is incorporated without validation into a URL redirect\n  res.redirect(req.param(\"target\"));\n});\n\n```\nOne way to remedy the problem is to validate the user input against a known fixed string before doing the redirection:\n\n\n```javascript\nconst app = require(\"express\")();\n\nconst VALID_REDIRECT = \"http://cwe.mitre.org/data/definitions/601.html\";\n\napp.get('/some/path', function(req, res) {\n  // GOOD: the request parameter is validated against a known fixed string\n  let target = req.param(\"target\");\n  if (VALID_REDIRECT === target)\n    res.redirect(target);\n});\n\n```\n\n## References\n* OWASP: [ XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "Untrusted URL redirection depends on a user-provided value."
      },
      "location": {
        "path": "routes/login.js",
        "start_line": 36,
        "end_line": 36,
        "start_column": 26,
        "end_column": 35
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/34/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 32,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/32",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/32",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/unsafe-html-expansion",
      "severity": "warning",
      "description": "Unsafe expansion of self-closing HTML tag",
      "name": "js/unsafe-html-expansion",
      "tags": [
        "correctness",
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "security"
      ],
      "full_description": "Using regular expressions to expand self-closing HTML tags may lead to cross-site scripting vulnerabilities.",
      "help": "# Unsafe expansion of self-closing HTML tag\nSanitizing untrusted input for HTML meta-characters is a common technique for preventing cross-site scripting attacks. But even a sanitized input can be dangerous to use if it is modified further before a browser treats it as HTML. A seemingly innocent transformation that expands a self-closing HTML tag from `<div attr=\"{sanitized}\"/>` to `<div attr=\"{sanitized}\"></div>` may in fact cause cross-site scripting vulnerabilities.\n\n\n## Recommendation\nUse a well-tested sanitization library if at all possible, and avoid modifying sanitized values further before treating them as HTML.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using HTML templates that are explicit about the values they treat as HTML.\n\n\n## Example\nThe following function transforms a self-closing HTML tag to a pair of open/close tags. It does so for all non-`img` and non-`area` tags, by using a regular expression with two capture groups. The first capture group corresponds to the name of the tag, and the second capture group to the content of the tag.\n\n\n```javascript\nfunction expandSelfClosingTags(html) {\n\tvar rxhtmlTag = /<(?!img|area)(([a-z][^\\w\\/>]*)[^>]*)\\/>/gi;\n\treturn html.replace(rxhtmlTag, \"<$1></$2>\"); // BAD\n}\n\n```\nWhile it is generally known regular expressions are ill-suited for parsing HTML, variants of this particular transformation pattern have long been considered safe.\n\nHowever, the function is not safe. As an example, consider the following string:\n\n\n```html\n<div alt=\"\n<x\" title=\"/>\n<img src=url404 onerror=alert(1)>\"/>\n\n```\nWhen the above function transforms the string, it becomes a string that results in an alert when a browser treats it as HTML.\n\n\n```html\n<div alt=\"\n<x\" title=\"></x\" >\n<img src=url404 onerror=alert(1)>\"/>\n\n```\n\n## References\n* jQuery: [Security fixes in jQuery 3.5.0](https://blog.jquery.com/2020/04/10/jquery-3-5-0-released/)\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [Types of Cross-Site](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "This self-closing HTML tag expansion invalidates prior sanitization as this regular expression may match part of an attribute value."
      },
      "location": {
        "path": "public/js/jquery.js",
        "start_line": 3,
        "end_line": 3,
        "start_column": 21896,
        "end_column": 21921
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/32/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 31,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/31",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/31",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/unsafe-html-expansion",
      "severity": "warning",
      "description": "Unsafe expansion of self-closing HTML tag",
      "name": "js/unsafe-html-expansion",
      "tags": [
        "correctness",
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "security"
      ],
      "full_description": "Using regular expressions to expand self-closing HTML tags may lead to cross-site scripting vulnerabilities.",
      "help": "# Unsafe expansion of self-closing HTML tag\nSanitizing untrusted input for HTML meta-characters is a common technique for preventing cross-site scripting attacks. But even a sanitized input can be dangerous to use if it is modified further before a browser treats it as HTML. A seemingly innocent transformation that expands a self-closing HTML tag from `<div attr=\"{sanitized}\"/>` to `<div attr=\"{sanitized}\"></div>` may in fact cause cross-site scripting vulnerabilities.\n\n\n## Recommendation\nUse a well-tested sanitization library if at all possible, and avoid modifying sanitized values further before treating them as HTML.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using HTML templates that are explicit about the values they treat as HTML.\n\n\n## Example\nThe following function transforms a self-closing HTML tag to a pair of open/close tags. It does so for all non-`img` and non-`area` tags, by using a regular expression with two capture groups. The first capture group corresponds to the name of the tag, and the second capture group to the content of the tag.\n\n\n```javascript\nfunction expandSelfClosingTags(html) {\n\tvar rxhtmlTag = /<(?!img|area)(([a-z][^\\w\\/>]*)[^>]*)\\/>/gi;\n\treturn html.replace(rxhtmlTag, \"<$1></$2>\"); // BAD\n}\n\n```\nWhile it is generally known regular expressions are ill-suited for parsing HTML, variants of this particular transformation pattern have long been considered safe.\n\nHowever, the function is not safe. As an example, consider the following string:\n\n\n```html\n<div alt=\"\n<x\" title=\"/>\n<img src=url404 onerror=alert(1)>\"/>\n\n```\nWhen the above function transforms the string, it becomes a string that results in an alert when a browser treats it as HTML.\n\n\n```html\n<div alt=\"\n<x\" title=\"></x\" >\n<img src=url404 onerror=alert(1)>\"/>\n\n```\n\n## References\n* jQuery: [Security fixes in jQuery 3.5.0](https://blog.jquery.com/2020/04/10/jquery-3-5-0-released/)\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [Types of Cross-Site](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "This self-closing HTML tag expansion invalidates prior sanitization as this regular expression may match part of an attribute value."
      },
      "location": {
        "path": "public/js/jquery.js",
        "start_line": 3,
        "end_line": 3,
        "start_column": 19206,
        "end_column": 19231
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/31/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 26,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/26",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/26",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/xss-through-dom",
      "severity": "warning",
      "description": "DOM text reinterpreted as HTML",
      "name": "js/xss-through-dom",
      "tags": [
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "security"
      ],
      "full_description": "Reinterpreting text from the DOM as HTML can lead to a cross-site scripting vulnerability.",
      "help": "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\nA webpage with this vulnerability reads text from the DOM, and afterwards adds the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes the text, and thereby invalidates any escaping done on the text. If an attacker is able to control the safe sanitized text, then this vulnerability can be exploited to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing text to the page, or one of the other solutions that are mentioned in the References section below.\n\n\n## Example\nThe following example shows a webpage using a `data-target` attribute to select and manipulate a DOM element using the JQuery library. In the example, the `data-target` attribute is read into the `target` variable, and the `$` function is then supposed to use the `target` variable as a CSS selector to determine which element should be manipulated.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can control the `data-target` attribute, then the value of `target` can be used to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability can be fixed by using `$.find` instead of `$`. The `$.find` function will only interpret `target` as a CSS selector and never as HTML, thereby preventing an XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "DOM text is reinterpreted as HTML without escaping meta-characters."
      },
      "location": {
        "path": "public/js/bootstrap.js",
        "start_line": 1557,
        "end_line": 1557,
        "start_column": 70,
        "end_column": 75
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/26/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 25,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/25",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/25",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/xss-through-dom",
      "severity": "warning",
      "description": "DOM text reinterpreted as HTML",
      "name": "js/xss-through-dom",
      "tags": [
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "security"
      ],
      "full_description": "Reinterpreting text from the DOM as HTML can lead to a cross-site scripting vulnerability.",
      "help": "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\nA webpage with this vulnerability reads text from the DOM, and afterwards adds the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes the text, and thereby invalidates any escaping done on the text. If an attacker is able to control the safe sanitized text, then this vulnerability can be exploited to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing text to the page, or one of the other solutions that are mentioned in the References section below.\n\n\n## Example\nThe following example shows a webpage using a `data-target` attribute to select and manipulate a DOM element using the JQuery library. In the example, the `data-target` attribute is read into the `target` variable, and the `$` function is then supposed to use the `target` variable as a CSS selector to determine which element should be manipulated.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can control the `data-target` attribute, then the value of `target` can be used to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability can be fixed by using `$.find` instead of `$`. The `$.find` function will only interpret `target` as a CSS selector and never as HTML, thereby preventing an XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "DOM text is reinterpreted as HTML without escaping meta-characters."
      },
      "location": {
        "path": "public/js/bootstrap.js",
        "start_line": 1233,
        "end_line": 1233,
        "start_column": 21,
        "end_column": 94
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/25/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 24,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/24",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/24",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/xss-through-dom",
      "severity": "warning",
      "description": "DOM text reinterpreted as HTML",
      "name": "js/xss-through-dom",
      "tags": [
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "security"
      ],
      "full_description": "Reinterpreting text from the DOM as HTML can lead to a cross-site scripting vulnerability.",
      "help": "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\nA webpage with this vulnerability reads text from the DOM, and afterwards adds the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes the text, and thereby invalidates any escaping done on the text. If an attacker is able to control the safe sanitized text, then this vulnerability can be exploited to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing text to the page, or one of the other solutions that are mentioned in the References section below.\n\n\n## Example\nThe following example shows a webpage using a `data-target` attribute to select and manipulate a DOM element using the JQuery library. In the example, the `data-target` attribute is read into the `target` variable, and the `$` function is then supposed to use the `target` variable as a CSS selector to determine which element should be manipulated.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can control the `data-target` attribute, then the value of `target` can be used to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability can be fixed by using `$.find` instead of `$`. The `$.find` function will only interpret `target` as a CSS selector and never as HTML, thereby preventing an XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "DOM text is reinterpreted as HTML without escaping meta-characters."
      },
      "location": {
        "path": "public/js/bootstrap.js",
        "start_line": 776,
        "end_line": 776,
        "start_column": 33,
        "end_column": 41
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/24/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 23,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/23",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/23",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/xss-through-dom",
      "severity": "warning",
      "description": "DOM text reinterpreted as HTML",
      "name": "js/xss-through-dom",
      "tags": [
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "security"
      ],
      "full_description": "Reinterpreting text from the DOM as HTML can lead to a cross-site scripting vulnerability.",
      "help": "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\nA webpage with this vulnerability reads text from the DOM, and afterwards adds the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes the text, and thereby invalidates any escaping done on the text. If an attacker is able to control the safe sanitized text, then this vulnerability can be exploited to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing text to the page, or one of the other solutions that are mentioned in the References section below.\n\n\n## Example\nThe following example shows a webpage using a `data-target` attribute to select and manipulate a DOM element using the JQuery library. In the example, the `data-target` attribute is read into the `target` variable, and the `$` function is then supposed to use the `target` variable as a CSS selector to determine which element should be manipulated.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can control the `data-target` attribute, then the value of `target` can be used to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability can be fixed by using `$.find` instead of `$`. The `$.find` function will only interpret `target` as a CSS selector and never as HTML, thereby preventing an XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "DOM text is reinterpreted as HTML without escaping meta-characters."
      },
      "location": {
        "path": "public/js/bootstrap.js",
        "start_line": 694,
        "end_line": 694,
        "start_column": 14,
        "end_column": 20
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/23/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 22,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/22",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/22",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/xss-through-dom",
      "severity": "warning",
      "description": "DOM text reinterpreted as HTML",
      "name": "js/xss-through-dom",
      "tags": [
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "security"
      ],
      "full_description": "Reinterpreting text from the DOM as HTML can lead to a cross-site scripting vulnerability.",
      "help": "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\nA webpage with this vulnerability reads text from the DOM, and afterwards adds the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes the text, and thereby invalidates any escaping done on the text. If an attacker is able to control the safe sanitized text, then this vulnerability can be exploited to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing text to the page, or one of the other solutions that are mentioned in the References section below.\n\n\n## Example\nThe following example shows a webpage using a `data-target` attribute to select and manipulate a DOM element using the JQuery library. In the example, the `data-target` attribute is read into the `target` variable, and the `$` function is then supposed to use the `target` variable as a CSS selector to determine which element should be manipulated.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can control the `data-target` attribute, then the value of `target` can be used to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability can be fixed by using `$.find` instead of `$`. The `$.find` function will only interpret `target` as a CSS selector and never as HTML, thereby preventing an XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "DOM text is reinterpreted as HTML without escaping meta-characters."
      },
      "location": {
        "path": "public/js/bootstrap.js",
        "start_line": 505,
        "end_line": 505,
        "start_column": 21,
        "end_column": 115
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/22/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 21,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/21",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/21",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/xss-through-dom",
      "severity": "warning",
      "description": "DOM text reinterpreted as HTML",
      "name": "js/xss-through-dom",
      "tags": [
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "security"
      ],
      "full_description": "Reinterpreting text from the DOM as HTML can lead to a cross-site scripting vulnerability.",
      "help": "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\nA webpage with this vulnerability reads text from the DOM, and afterwards adds the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes the text, and thereby invalidates any escaping done on the text. If an attacker is able to control the safe sanitized text, then this vulnerability can be exploited to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing text to the page, or one of the other solutions that are mentioned in the References section below.\n\n\n## Example\nThe following example shows a webpage using a `data-target` attribute to select and manipulate a DOM element using the JQuery library. In the example, the `data-target` attribute is read into the `target` variable, and the `$` function is then supposed to use the `target` variable as a CSS selector to determine which element should be manipulated.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can control the `data-target` attribute, then the value of `target` can be used to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability can be fixed by using `$.find` instead of `$`. The `$.find` function will only interpret `target` as a CSS selector and never as HTML, thereby preventing an XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "DOM text is reinterpreted as HTML without escaping meta-characters."
      },
      "location": {
        "path": "public/js/bootstrap.js",
        "start_line": 112,
        "end_line": 112,
        "start_column": 21,
        "end_column": 29
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/21/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 20,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/20",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/20",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/xss",
      "severity": "error",
      "description": "Client-side cross-site scripting",
      "name": "js/xss",
      "tags": [
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "security"
      ],
      "full_description": "Writing user input directly to the DOM allows for a cross-site scripting vulnerability.",
      "help": "# Client-side cross-site scripting\nDirectly writing user input (for example, a URL query parameter) to a webpage without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\nThis kind of vulnerability is also called *DOM-based* cross-site scripting, to distinguish it from other types of cross-site scripting.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the page, or one of the other solutions that are mentioned in the references.\n\n\n## Example\nThe following example shows part of the page URL being written directly to the document, leaving the website vulnerable to cross-site scripting.\n\n\n```javascript\nfunction setLanguageOptions() {\n    var href = document.location.href,\n        deflt = href.substring(href.indexOf(\"default=\")+8);\n    document.write(\"<OPTION value=1>\"+deflt+\"</OPTION>\");\n    document.write(\"<OPTION value=2>English</OPTION>\");\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "Cross-site scripting vulnerability due to user-provided value."
      },
      "location": {
        "path": "views/search.ejs",
        "start_line": 3,
        "end_line": 3,
        "start_column": 18,
        "end_column": 33
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/20/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 19,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/19",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/19",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/xss",
      "severity": "error",
      "description": "Client-side cross-site scripting",
      "name": "js/xss",
      "tags": [
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "security"
      ],
      "full_description": "Writing user input directly to the DOM allows for a cross-site scripting vulnerability.",
      "help": "# Client-side cross-site scripting\nDirectly writing user input (for example, a URL query parameter) to a webpage without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\nThis kind of vulnerability is also called *DOM-based* cross-site scripting, to distinguish it from other types of cross-site scripting.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the page, or one of the other solutions that are mentioned in the references.\n\n\n## Example\nThe following example shows part of the page URL being written directly to the document, leaving the website vulnerable to cross-site scripting.\n\n\n```javascript\nfunction setLanguageOptions() {\n    var href = document.location.href,\n        deflt = href.substring(href.indexOf(\"default=\")+8);\n    document.write(\"<OPTION value=1>\"+deflt+\"</OPTION>\");\n    document.write(\"<OPTION value=2>English</OPTION>\");\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "Cross-site scripting vulnerability due to user-provided value."
      },
      "location": {
        "path": "views/login.ejs",
        "start_line": 22,
        "end_line": 22,
        "start_column": 46,
        "end_column": 61
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/19/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 18,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/18",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/18",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/xss",
      "severity": "error",
      "description": "Client-side cross-site scripting",
      "name": "js/xss",
      "tags": [
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "security"
      ],
      "full_description": "Writing user input directly to the DOM allows for a cross-site scripting vulnerability.",
      "help": "# Client-side cross-site scripting\nDirectly writing user input (for example, a URL query parameter) to a webpage without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\nThis kind of vulnerability is also called *DOM-based* cross-site scripting, to distinguish it from other types of cross-site scripting.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the page, or one of the other solutions that are mentioned in the references.\n\n\n## Example\nThe following example shows part of the page URL being written directly to the document, leaving the website vulnerable to cross-site scripting.\n\n\n```javascript\nfunction setLanguageOptions() {\n    var href = document.location.href,\n        deflt = href.substring(href.indexOf(\"default=\")+8);\n    document.write(\"<OPTION value=1>\"+deflt+\"</OPTION>\");\n    document.write(\"<OPTION value=2>English</OPTION>\");\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "Cross-site scripting vulnerability due to user-provided value."
      },
      "location": {
        "path": "views/login.ejs",
        "start_line": 17,
        "end_line": 17,
        "start_column": 94,
        "end_column": 108
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/18/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 17,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/17",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/17",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/unsafe-jquery-plugin",
      "severity": "warning",
      "description": "Unsafe jQuery plugin",
      "name": "js/unsafe-jquery-plugin",
      "tags": [
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "frameworks/jquery",
        "security"
      ],
      "full_description": "A jQuery plugin that unintentionally constructs HTML from some of its options may be unsafe to use for clients.",
      "help": "# Unsafe jQuery plugin\nLibrary plugins, such as those for the jQuery library, are often configurable through options provided by the clients of the plugin. Clients, however, do not know the implementation details of the plugin, so it is important to document the capabilities of each option. The documentation for the plugin options that the client is responsible for sanitizing is of particular importance. Otherwise, the plugin may write user input (for example, a URL query parameter) to a web page without properly sanitizing it first, which allows for a cross-site scripting vulnerability in the client application through dynamic HTML construction.\n\n\n## Recommendation\nDocument all options that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.\n\n\n## Example\nThe following example shows a jQuery plugin that selects a DOM element, and copies its text content to another DOM element. The selection is performed by using the plugin option `sourceSelector` as a CSS selector.\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// BAD may evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\nThis is, however, not a safe plugin, since the call to `jQuery` interprets `sourceSelector` as HTML if it is a string that starts with `<`.\n\nInstead of documenting that the client is responsible for sanitizing `sourceSelector`, the plugin can use `jQuery.find` to always interpret `sourceSelector` as a CSS selector:\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// GOOD may not evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery.find(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* jQuery: [Plugin creation](https://learn.jquery.com/plugins/basic-plugin-creation/).\n* Bootstrap: [XSS vulnerable bootstrap plugins](https://github.com/twbs/bootstrap/pull/27047).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "Potential XSS vulnerability in the '$.fn.affix' plugin."
      },
      "location": {
        "path": "public/js/bootstrap.js",
        "start_line": 2220,
        "end_line": 2220,
        "start_column": 22,
        "end_column": 41
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/17/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 16,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/16",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/16",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/unsafe-jquery-plugin",
      "severity": "warning",
      "description": "Unsafe jQuery plugin",
      "name": "js/unsafe-jquery-plugin",
      "tags": [
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "frameworks/jquery",
        "security"
      ],
      "full_description": "A jQuery plugin that unintentionally constructs HTML from some of its options may be unsafe to use for clients.",
      "help": "# Unsafe jQuery plugin\nLibrary plugins, such as those for the jQuery library, are often configurable through options provided by the clients of the plugin. Clients, however, do not know the implementation details of the plugin, so it is important to document the capabilities of each option. The documentation for the plugin options that the client is responsible for sanitizing is of particular importance. Otherwise, the plugin may write user input (for example, a URL query parameter) to a web page without properly sanitizing it first, which allows for a cross-site scripting vulnerability in the client application through dynamic HTML construction.\n\n\n## Recommendation\nDocument all options that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.\n\n\n## Example\nThe following example shows a jQuery plugin that selects a DOM element, and copies its text content to another DOM element. The selection is performed by using the plugin option `sourceSelector` as a CSS selector.\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// BAD may evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\nThis is, however, not a safe plugin, since the call to `jQuery` interprets `sourceSelector` as HTML if it is a string that starts with `<`.\n\nInstead of documenting that the client is responsible for sanitizing `sourceSelector`, the plugin can use `jQuery.find` to always interpret `sourceSelector` as a CSS selector:\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// GOOD may not evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery.find(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* jQuery: [Plugin creation](https://learn.jquery.com/plugins/basic-plugin-creation/).\n* Bootstrap: [XSS vulnerable bootstrap plugins](https://github.com/twbs/bootstrap/pull/27047).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "Potential XSS vulnerability in the '$.fn.scrollspy' plugin."
      },
      "location": {
        "path": "public/js/bootstrap.js",
        "start_line": 1999,
        "end_line": 1999,
        "start_column": 7,
        "end_column": 20
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/16/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 15,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/15",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/15",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/unsafe-jquery-plugin",
      "severity": "warning",
      "description": "Unsafe jQuery plugin",
      "name": "js/unsafe-jquery-plugin",
      "tags": [
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "frameworks/jquery",
        "security"
      ],
      "full_description": "A jQuery plugin that unintentionally constructs HTML from some of its options may be unsafe to use for clients.",
      "help": "# Unsafe jQuery plugin\nLibrary plugins, such as those for the jQuery library, are often configurable through options provided by the clients of the plugin. Clients, however, do not know the implementation details of the plugin, so it is important to document the capabilities of each option. The documentation for the plugin options that the client is responsible for sanitizing is of particular importance. Otherwise, the plugin may write user input (for example, a URL query parameter) to a web page without properly sanitizing it first, which allows for a cross-site scripting vulnerability in the client application through dynamic HTML construction.\n\n\n## Recommendation\nDocument all options that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.\n\n\n## Example\nThe following example shows a jQuery plugin that selects a DOM element, and copies its text content to another DOM element. The selection is performed by using the plugin option `sourceSelector` as a CSS selector.\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// BAD may evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\nThis is, however, not a safe plugin, since the call to `jQuery` interprets `sourceSelector` as HTML if it is a string that starts with `<`.\n\nInstead of documenting that the client is responsible for sanitizing `sourceSelector`, the plugin can use `jQuery.find` to always interpret `sourceSelector` as a CSS selector:\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// GOOD may not evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery.find(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* jQuery: [Plugin creation](https://learn.jquery.com/plugins/basic-plugin-creation/).\n* Bootstrap: [XSS vulnerable bootstrap plugins](https://github.com/twbs/bootstrap/pull/27047).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "Potential XSS vulnerability in the '$.fn.scrollspy' plugin."
      },
      "location": {
        "path": "public/js/bootstrap.js",
        "start_line": 1985,
        "end_line": 1985,
        "start_column": 20,
        "end_column": 28
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/15/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 14,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/14",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/14",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/unsafe-jquery-plugin",
      "severity": "warning",
      "description": "Unsafe jQuery plugin",
      "name": "js/unsafe-jquery-plugin",
      "tags": [
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "frameworks/jquery",
        "security"
      ],
      "full_description": "A jQuery plugin that unintentionally constructs HTML from some of its options may be unsafe to use for clients.",
      "help": "# Unsafe jQuery plugin\nLibrary plugins, such as those for the jQuery library, are often configurable through options provided by the clients of the plugin. Clients, however, do not know the implementation details of the plugin, so it is important to document the capabilities of each option. The documentation for the plugin options that the client is responsible for sanitizing is of particular importance. Otherwise, the plugin may write user input (for example, a URL query parameter) to a web page without properly sanitizing it first, which allows for a cross-site scripting vulnerability in the client application through dynamic HTML construction.\n\n\n## Recommendation\nDocument all options that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.\n\n\n## Example\nThe following example shows a jQuery plugin that selects a DOM element, and copies its text content to another DOM element. The selection is performed by using the plugin option `sourceSelector` as a CSS selector.\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// BAD may evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\nThis is, however, not a safe plugin, since the call to `jQuery` interprets `sourceSelector` as HTML if it is a string that starts with `<`.\n\nInstead of documenting that the client is responsible for sanitizing `sourceSelector`, the plugin can use `jQuery.find` to always interpret `sourceSelector` as a CSS selector:\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// GOOD may not evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery.find(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* jQuery: [Plugin creation](https://learn.jquery.com/plugins/basic-plugin-creation/).\n* Bootstrap: [XSS vulnerable bootstrap plugins](https://github.com/twbs/bootstrap/pull/27047).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "Potential XSS vulnerability in the '$.fn.tooltip' plugin."
      },
      "location": {
        "path": "public/js/bootstrap.js",
        "start_line": 1455,
        "end_line": 1455,
        "start_column": 46,
        "end_column": 68
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/14/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 13,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/13",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/13",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/unsafe-jquery-plugin",
      "severity": "warning",
      "description": "Unsafe jQuery plugin",
      "name": "js/unsafe-jquery-plugin",
      "tags": [
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "frameworks/jquery",
        "security"
      ],
      "full_description": "A jQuery plugin that unintentionally constructs HTML from some of its options may be unsafe to use for clients.",
      "help": "# Unsafe jQuery plugin\nLibrary plugins, such as those for the jQuery library, are often configurable through options provided by the clients of the plugin. Clients, however, do not know the implementation details of the plugin, so it is important to document the capabilities of each option. The documentation for the plugin options that the client is responsible for sanitizing is of particular importance. Otherwise, the plugin may write user input (for example, a URL query parameter) to a web page without properly sanitizing it first, which allows for a cross-site scripting vulnerability in the client application through dynamic HTML construction.\n\n\n## Recommendation\nDocument all options that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.\n\n\n## Example\nThe following example shows a jQuery plugin that selects a DOM element, and copies its text content to another DOM element. The selection is performed by using the plugin option `sourceSelector` as a CSS selector.\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// BAD may evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\nThis is, however, not a safe plugin, since the call to `jQuery` interprets `sourceSelector` as HTML if it is a string that starts with `<`.\n\nInstead of documenting that the client is responsible for sanitizing `sourceSelector`, the plugin can use `jQuery.find` to always interpret `sourceSelector` as a CSS selector:\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// GOOD may not evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery.find(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* jQuery: [Plugin creation](https://learn.jquery.com/plugins/basic-plugin-creation/).\n* Bootstrap: [XSS vulnerable bootstrap plugins](https://github.com/twbs/bootstrap/pull/27047).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "Potential XSS vulnerability in the '$.fn.tooltip' plugin."
      },
      "location": {
        "path": "public/js/bootstrap.js",
        "start_line": 1302,
        "end_line": 1302,
        "start_column": 49,
        "end_column": 194
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/13/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 12,
    "created_at": "2022-08-22T22:05:00Z",
    "updated_at": "2023-05-11T02:47:08Z",
    "url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/12",
    "html_url": "https://github.com/austenstone/vulnerable-node/security/code-scanning/12",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "js/unsafe-jquery-plugin",
      "severity": "warning",
      "description": "Unsafe jQuery plugin",
      "name": "js/unsafe-jquery-plugin",
      "tags": [
        "external/cwe/cwe-079",
        "external/cwe/cwe-116",
        "frameworks/jquery",
        "security"
      ],
      "full_description": "A jQuery plugin that unintentionally constructs HTML from some of its options may be unsafe to use for clients.",
      "help": "# Unsafe jQuery plugin\nLibrary plugins, such as those for the jQuery library, are often configurable through options provided by the clients of the plugin. Clients, however, do not know the implementation details of the plugin, so it is important to document the capabilities of each option. The documentation for the plugin options that the client is responsible for sanitizing is of particular importance. Otherwise, the plugin may write user input (for example, a URL query parameter) to a web page without properly sanitizing it first, which allows for a cross-site scripting vulnerability in the client application through dynamic HTML construction.\n\n\n## Recommendation\nDocument all options that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.\n\n\n## Example\nThe following example shows a jQuery plugin that selects a DOM element, and copies its text content to another DOM element. The selection is performed by using the plugin option `sourceSelector` as a CSS selector.\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// BAD may evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\nThis is, however, not a safe plugin, since the call to `jQuery` interprets `sourceSelector` as HTML if it is a string that starts with `<`.\n\nInstead of documenting that the client is responsible for sanitizing `sourceSelector`, the plugin can use `jQuery.find` to always interpret `sourceSelector` as a CSS selector:\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// GOOD may not evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery.find(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* jQuery: [Plugin creation](https://learn.jquery.com/plugins/basic-plugin-creation/).\n* Bootstrap: [XSS vulnerable bootstrap plugins](https://github.com/twbs/bootstrap/pull/27047).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
      "security_severity_level": "medium"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.13.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/main",
      "analysis_key": ".github/workflows/codeql2.yml:analyze",
      "environment": "{\"language\":\"javascript\"}",
      "category": "/language:javascript",
      "state": "open",
      "commit_sha": "a4bea5ae7adeb4deccb127906edcd278c98668b6",
      "message": {
        "text": "Potential XSS vulnerability in the '$.fn.collapse' plugin."
      },
      "location": {
        "path": "public/js/bootstrap.js",
        "start_line": 671,
        "end_line": 671,
        "start_column": 14,
        "end_column": 33
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/austenstone/vulnerable-node/code-scanning/alerts/12/instances",
    "dismissal_approved_by": null
  }
]